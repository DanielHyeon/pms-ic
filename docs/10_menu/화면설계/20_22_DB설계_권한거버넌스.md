# 20~22. DB Design: Authority & Governance (Postgres + Neo4j)

> Created: 2026-02-09
> Version: v1.0
> Scope: #20 Authority Anchor + #21 Assignment Layer + #22 Authority Orchestration
> Related Docs:
>   - [20_프로젝트관리_책임주체_화면설계.md](20_프로젝트관리_책임주체_화면설계.md)
>   - [21_파트관리_화면설계.md](21_파트관리_화면설계.md)
>   - [22_역할권한관리_화면설계.md](22_역할권한관리_화면설계.md)

---

## 0. Architecture Overview

### 0.1 Dual-DB Strategy

```
┌──────────────────────────────────────────────────────────────────┐
│                          Application                              │
│                                                                    │
│  ┌──────────────┐       ┌──────────────┐       ┌──────────────┐   │
│  │  #20 Screen  │       │  #21 Screen  │       │  #22 Screen  │   │
│  │  Authority   │       │  Assignment  │       │  Governance  │   │
│  │  Anchor      │       │  Layer       │       │  Orchestrate │   │
│  └──────┬───────┘       └──────┬───────┘       └──────┬───────┘   │
│         │                      │                      │           │
│         ▼                      ▼                      ▼           │
│  ┌────────────────────────────────────────────────────────────┐   │
│  │                    Service Layer (R2DBC)                    │   │
│  │                                                            │   │
│  │  - WRITE: Always Postgres (SoT)                            │   │
│  │  - READ (facts): Postgres (accuracy)                       │   │
│  │  - READ (graph): Neo4j (traversal/visualization)           │   │
│  └──────────────────────┬─────────────────────────────────────┘   │
│                         │                                         │
│         ┌───────────────┼───────────────┐                         │
│         ▼               ▼               ▼                         │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐                 │
│  │  Postgres   │ │  Outbox     │ │   Neo4j     │                 │
│  │  (SoT)      │ │  Worker     │ │  (Graph)    │                 │
│  │             │ │             │ │             │                 │
│  │ governance  │ │  Reads      │ │ Projection  │                 │
│  │ organization│→│  outbox     │→│ for visual  │                 │
│  │             │ │  events     │ │ + traversal │                 │
│  └─────────────┘ └─────────────┘ └─────────────┘                 │
└──────────────────────────────────────────────────────────────────┘
```

| DB | Role | Responsibility |
|----|------|---------------|
| **Postgres** | Single Source of Truth (SoT) | All writes, fact storage, audit trail, effective capability calculation, SoD validation |
| **Neo4j** | Query Accelerator (Projection) | Delegation map traversal, authority flow visualization, impact analysis |

### 0.2 Core Design Rules

| Rule | Description |
|------|-------------|
| **Write SoT only** | All mutations (create/update/delete) go through Postgres only |
| **Compute, don't store** | Effective Capability is computed via views, not stored as fact |
| **Re-delegation by config** | `allow_redelegation` on Capability controls re-delegation (default: off) |
| **Time-aware status** | Delegation active status = `status='ACTIVE' AND date_range_check` |
| **Immutable audit log** | All permission changes are logged to `permission_audit_log` (append-only) |
| **Outbox sync** | Postgres-to-Neo4j via outbox pattern with idempotent MERGE |

### 0.3 Schema Map

| Postgres Schema | Screen | Purpose |
|----------------|--------|---------|
| `governance` | #20, #22 | project_accountability, roles, capabilities, delegations, audit, SoD, outbox |
| `organization` | #21 | parts, part_memberships, part_co_leaders, assignment_change_log |
| `project` (existing) | All | projects table (FK target) |

---

## 1. Postgres DDL: #20 Authority Anchor

> **Screen**: Project Management (Authority Anchor)
> **Tables**: `governance.project_accountability`, `governance.accountability_change_log`

### 1.1 project_accountability (Current State)

```sql
-- Project accountability: current responsible persons (mutable, always 1 row per project)
CREATE TABLE IF NOT EXISTS governance.project_accountability (
  project_id            UUID PRIMARY KEY,
  primary_pm_user_id    UUID NOT NULL,
  co_pm_user_id         UUID NULL,
  sponsor_user_id       UUID NULL,

  updated_at            TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_by            UUID NOT NULL
);
```

| Column | Type | Constraint | Description |
|--------|------|-----------|-------------|
| `project_id` | UUID | PK | 1:1 with project |
| `primary_pm_user_id` | UUID | NOT NULL | Primary PM - must always exist, no vacancy |
| `co_pm_user_id` | UUID | NULLABLE | Co-PM (optional) |
| `sponsor_user_id` | UUID | NULLABLE | Sponsor/approval authority (optional) |
| `updated_at` | TIMESTAMPTZ | DEFAULT now() | Last update timestamp |
| `updated_by` | UUID | NOT NULL | User who performed the update |

### 1.2 accountability_change_log (Immutable History)

```sql
-- Accountability change log: immutable audit trail for #20 screen
CREATE TABLE IF NOT EXISTS governance.accountability_change_log (
  id                    UUID PRIMARY KEY,
  project_id            UUID NOT NULL,
  change_type           TEXT NOT NULL CHECK (change_type IN ('PM_CHANGE','CO_PM_CHANGE','SPONSOR_CHANGE')),

  previous_user_id      UUID NULL,
  new_user_id           UUID NULL,

  changed_by            UUID NOT NULL,
  change_reason         TEXT NOT NULL,
  changed_at            TIMESTAMPTZ NOT NULL DEFAULT now(),

  CONSTRAINT fk_acc_log_project
    FOREIGN KEY (project_id) REFERENCES project.projects(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_acc_log_project_time
  ON governance.accountability_change_log(project_id, changed_at DESC);
```

| Column | Type | Constraint | Description |
|--------|------|-----------|-------------|
| `id` | UUID | PK | Change log entry ID |
| `project_id` | UUID | FK(project.projects) | Target project |
| `change_type` | TEXT | CHECK | `PM_CHANGE`, `CO_PM_CHANGE`, `SPONSOR_CHANGE` |
| `previous_user_id` | UUID | NULLABLE | Previous responsible person (null for initial assignment) |
| `new_user_id` | UUID | NULLABLE | New responsible person |
| `changed_by` | UUID | NOT NULL | User who performed the change |
| `change_reason` | TEXT | NOT NULL | Mandatory reason (enforced by #20 screen) |
| `changed_at` | TIMESTAMPTZ | DEFAULT now() | Change timestamp |

**Design Notes:**
- `project_accountability` = mutable current state (exactly 1 row per project)
- `accountability_change_log` = append-only immutable audit trail
- `change_reason NOT NULL` enforces #20's "no reason = no change" rule

---

## 2. Postgres DDL: #21 Assignment Layer

> **Screen**: Part Management (Assignment Layer)
> **Tables**: `organization.parts`, `organization.part_co_leaders`, `organization.part_memberships`, `organization.assignment_change_log`

### 2.1 parts

```sql
CREATE TABLE IF NOT EXISTS organization.parts (
  id                UUID PRIMARY KEY,
  project_id        UUID NOT NULL,
  name              TEXT NOT NULL,
  part_type         TEXT NOT NULL CHECK (part_type IN (
                      'AI_DEVELOPMENT','SI_DEVELOPMENT','QA',
                      'BUSINESS_ANALYSIS','COMMON','PMO','CUSTOM'
                    )),
  custom_type_name  TEXT NULL,
  status            TEXT NOT NULL DEFAULT 'ACTIVE' CHECK (status IN ('ACTIVE','CLOSED')),

  leader_user_id    UUID NULL,    -- Primary leader (required for ACTIVE parts, enforced at service layer)
  created_at        TIMESTAMPTZ NOT NULL DEFAULT now(),
  created_by        UUID NOT NULL,
  closed_at         TIMESTAMPTZ NULL,
  closed_by         UUID NULL,

  CONSTRAINT fk_parts_project
    FOREIGN KEY (project_id) REFERENCES project.projects(id) ON DELETE CASCADE,

  -- CUSTOM type requires custom_type_name
  CONSTRAINT chk_custom_type_name
    CHECK ((part_type <> 'CUSTOM') OR (custom_type_name IS NOT NULL AND length(custom_type_name) > 0))
);

CREATE INDEX IF NOT EXISTS idx_parts_project_status
  ON organization.parts(project_id, status);

CREATE INDEX IF NOT EXISTS idx_parts_project_type
  ON organization.parts(project_id, part_type);
```

| Column | Type | Constraint | Description |
|--------|------|-----------|-------------|
| `id` | UUID | PK | Part ID |
| `project_id` | UUID | FK | Parent project |
| `name` | TEXT | NOT NULL | Part display name |
| `part_type` | TEXT | CHECK(7 values) | `AI_DEVELOPMENT`, `SI_DEVELOPMENT`, `QA`, `BUSINESS_ANALYSIS`, `COMMON`, `PMO`, `CUSTOM` |
| `custom_type_name` | TEXT | NULLABLE | Required when `part_type='CUSTOM'` (DB CHECK enforced) |
| `status` | TEXT | DEFAULT 'ACTIVE' | `ACTIVE` or `CLOSED` (close = soft delete) |
| `leader_user_id` | UUID | NULLABLE | Primary part leader. ACTIVE parts must have a leader (service layer enforced) |
| `closed_at` / `closed_by` | TIMESTAMPTZ / UUID | NULLABLE | Populated on close |

### 2.2 part_co_leaders

```sql
-- Co-leaders: optional supplementary leaders (0..N per part)
CREATE TABLE IF NOT EXISTS organization.part_co_leaders (
  part_id       UUID NOT NULL,
  user_id       UUID NOT NULL,
  created_at    TIMESTAMPTZ NOT NULL DEFAULT now(),
  created_by    UUID NOT NULL,

  PRIMARY KEY (part_id, user_id),
  FOREIGN KEY (part_id) REFERENCES organization.parts(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_part_co_leaders_user
  ON organization.part_co_leaders(user_id);
```

### 2.3 part_memberships

```sql
CREATE TABLE IF NOT EXISTS organization.part_memberships (
  id                UUID PRIMARY KEY,
  project_id        UUID NOT NULL,
  part_id           UUID NOT NULL,
  user_id           UUID NOT NULL,
  membership_type   TEXT NOT NULL CHECK (membership_type IN ('PRIMARY','SECONDARY')),

  joined_at         TIMESTAMPTZ NOT NULL DEFAULT now(),
  joined_by         UUID NOT NULL,
  left_at           TIMESTAMPTZ NULL,
  left_by           UUID NULL,

  FOREIGN KEY (part_id) REFERENCES organization.parts(id) ON DELETE CASCADE,
  FOREIGN KEY (project_id) REFERENCES project.projects(id) ON DELETE CASCADE
);

-- Active memberships: fast lookup
CREATE INDEX IF NOT EXISTS idx_memberships_part_active
  ON organization.part_memberships(part_id)
  WHERE left_at IS NULL;

CREATE INDEX IF NOT EXISTS idx_memberships_user_active
  ON organization.part_memberships(project_id, user_id)
  WHERE left_at IS NULL;

-- PRIMARY uniqueness: exactly one PRIMARY per user per project (among active memberships)
CREATE UNIQUE INDEX IF NOT EXISTS uq_user_primary_membership
  ON organization.part_memberships(project_id, user_id)
  WHERE left_at IS NULL AND membership_type = 'PRIMARY';
```

**Critical Index: `uq_user_primary_membership`**
- Partial unique index enforces: one active PRIMARY membership per user per project
- This is the DB-level guarantee for #21's "Primary single" rule
- "Last membership removal block" is handled at service layer (DB cannot express this constraint)

### 2.4 assignment_change_log

```sql
-- Assignment change log: audit trail for part/membership changes
CREATE TABLE IF NOT EXISTS organization.assignment_change_log (
  id              UUID PRIMARY KEY,
  project_id      UUID NOT NULL,
  part_id         UUID NULL,
  user_id         UUID NOT NULL,
  change_type     TEXT NOT NULL CHECK (change_type IN (
                    'MEMBERSHIP_ADD','MEMBERSHIP_REMOVE','PRIMARY_SWITCH',
                    'LEADER_CHANGE','PART_CLOSE','PART_OPEN'
                  )),
  previous_value  TEXT NULL,
  new_value       TEXT NULL,
  changed_by      UUID NOT NULL,
  change_reason   TEXT NULL,
  changed_at      TIMESTAMPTZ NOT NULL DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_assignment_log_project_time
  ON organization.assignment_change_log(project_id, changed_at DESC);
```

---

## 3. Postgres DDL: #22 Authority Orchestration

> **Screen**: Role & Capability Management (Authority Orchestration)
> **Tables**: `governance.roles`, `governance.capabilities`, `governance.role_capabilities`, `governance.user_roles`, `governance.user_capabilities`, `governance.delegations`, `governance.permission_audit_log`, `governance.sod_rules`, `governance.governance_check_runs`, `governance.governance_findings`

### 3.1 roles

```sql
CREATE TABLE IF NOT EXISTS governance.roles (
  id              UUID PRIMARY KEY,
  project_id      UUID NULL,     -- NULL = global role, non-null = project-scoped custom role
  code            TEXT NOT NULL,  -- 'PM','QA_LEAD','DEVELOPER'...
  name            TEXT NOT NULL,
  description     TEXT NULL,
  is_project_scoped BOOLEAN NOT NULL DEFAULT true,
  created_at      TIMESTAMPTZ NOT NULL DEFAULT now(),
  created_by      UUID NOT NULL
);

-- Unique role code per scope (global or project)
CREATE UNIQUE INDEX IF NOT EXISTS uq_roles_scope_code
  ON governance.roles(COALESCE(project_id, '00000000-0000-0000-0000-000000000000'::UUID), code);
```

| Column | Type | Constraint | Description |
|--------|------|-----------|-------------|
| `project_id` | UUID | NULLABLE | NULL for global roles (PM, DEVELOPER, etc.), non-null for project-custom roles |
| `code` | TEXT | Unique per scope | Role code: `PM`, `CO_PM`, `PMO_HEAD`, `PMO_MEMBER`, `SPONSOR`, `PART_LEADER`, `DEV_LEAD`, `QA_LEAD`, `DEVELOPER`, `QA_ENGINEER`, `BUSINESS_ANALYST`, `MEMBER` |
| `is_project_scoped` | BOOLEAN | DEFAULT true | Whether this role operates at project level |

### 3.2 capabilities

```sql
CREATE TABLE IF NOT EXISTS governance.capabilities (
  id                  UUID PRIMARY KEY,
  code                TEXT NOT NULL UNIQUE,  -- 'approve_test', 'manage_delegations'...
  name                TEXT NOT NULL,
  category            TEXT NOT NULL CHECK (category IN (
                        'APPROVAL','MANAGEMENT','VIEW','EXECUTION','GOVERNANCE'
                      )),
  description         TEXT NULL,
  is_delegatable      BOOLEAN NOT NULL DEFAULT false,
  allow_redelegation  BOOLEAN NOT NULL DEFAULT false,
  created_at          TIMESTAMPTZ NOT NULL DEFAULT now(),
  created_by          UUID NOT NULL
);
```

| Column | Type | Constraint | Description |
|--------|------|-----------|-------------|
| `code` | TEXT | UNIQUE | Capability code following naming convention: `{action}_{domain}` or `{action}_{domain}_{target}` |
| `category` | TEXT | CHECK(5) | `APPROVAL`, `MANAGEMENT`, `VIEW`, `EXECUTION`, `GOVERNANCE` |
| `is_delegatable` | BOOLEAN | DEFAULT false | Whether this capability can be delegated |
| `allow_redelegation` | BOOLEAN | DEFAULT false | Whether re-delegation is allowed (v1.1 - default off) |

### 3.3 role_capabilities (Role-Preset Mapping)

```sql
CREATE TABLE IF NOT EXISTS governance.role_capabilities (
  role_id       UUID NOT NULL,
  capability_id UUID NOT NULL,

  PRIMARY KEY (role_id, capability_id),
  FOREIGN KEY (role_id) REFERENCES governance.roles(id) ON DELETE CASCADE,
  FOREIGN KEY (capability_id) REFERENCES governance.capabilities(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_role_caps_cap
  ON governance.role_capabilities(capability_id);
```

### 3.4 user_roles (Role Assignment)

```sql
CREATE TABLE IF NOT EXISTS governance.user_roles (
  id          UUID PRIMARY KEY,
  project_id  UUID NOT NULL,
  user_id     UUID NOT NULL,
  role_id     UUID NOT NULL,
  granted_by  UUID NOT NULL,
  granted_at  TIMESTAMPTZ NOT NULL DEFAULT now(),
  reason      TEXT NULL,

  FOREIGN KEY (role_id) REFERENCES governance.roles(id) ON DELETE CASCADE,
  FOREIGN KEY (project_id) REFERENCES project.projects(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_user_roles_project_user
  ON governance.user_roles(project_id, user_id);

CREATE INDEX IF NOT EXISTS idx_user_roles_project_role
  ON governance.user_roles(project_id, role_id);
```

### 3.5 user_capabilities (Direct Grant)

```sql
CREATE TABLE IF NOT EXISTS governance.user_capabilities (
  id            UUID PRIMARY KEY,
  project_id    UUID NOT NULL,
  user_id       UUID NOT NULL,
  capability_id UUID NOT NULL,
  granted_by    UUID NOT NULL,
  granted_at    TIMESTAMPTZ NOT NULL DEFAULT now(),
  reason        TEXT NULL,

  FOREIGN KEY (capability_id) REFERENCES governance.capabilities(id) ON DELETE CASCADE,
  FOREIGN KEY (project_id) REFERENCES project.projects(id) ON DELETE CASCADE
);

-- One direct grant per user per capability per project
CREATE UNIQUE INDEX IF NOT EXISTS uq_user_cap_project_user_cap
  ON governance.user_capabilities(project_id, user_id, capability_id);
```

### 3.6 delegations (Core Entity)

```sql
CREATE TABLE IF NOT EXISTS governance.delegations (
  id                  UUID PRIMARY KEY,
  project_id          UUID NOT NULL,

  delegator_id        UUID NOT NULL,
  delegatee_id        UUID NOT NULL,

  capability_id       UUID NOT NULL,

  -- Scope
  scope_type          TEXT NOT NULL CHECK (scope_type IN ('PROJECT','PART','FUNCTION')),
  scope_part_id       UUID NULL,
  scope_function_desc TEXT NULL,

  -- Duration
  duration_type       TEXT NOT NULL CHECK (duration_type IN ('PERMANENT','TEMPORARY')),
  start_at            DATE NOT NULL,
  end_at              DATE NULL,

  -- Approval
  approver_id         UUID NOT NULL,
  approved_at         TIMESTAMPTZ NOT NULL DEFAULT now(),

  -- Status
  status              TEXT NOT NULL DEFAULT 'ACTIVE' CHECK (status IN ('ACTIVE','EXPIRED','REVOKED','PENDING')),
  created_at          TIMESTAMPTZ NOT NULL DEFAULT now(),
  created_by          UUID NOT NULL,

  -- Revocation
  revoked_at          TIMESTAMPTZ NULL,
  revoked_by          UUID NULL,
  revoke_reason       TEXT NULL,

  -- Re-delegation chain (v1.1)
  parent_delegation_id UUID NULL,

  -- FK
  FOREIGN KEY (capability_id) REFERENCES governance.capabilities(id),
  FOREIGN KEY (project_id) REFERENCES project.projects(id) ON DELETE CASCADE,
  FOREIGN KEY (scope_part_id) REFERENCES organization.parts(id) ON DELETE SET NULL,
  FOREIGN KEY (parent_delegation_id) REFERENCES governance.delegations(id) ON DELETE SET NULL,

  -- Business Rules as CHECK constraints
  CONSTRAINT chk_temp_end_required
    CHECK ((duration_type = 'TEMPORARY' AND end_at IS NOT NULL) OR (duration_type = 'PERMANENT')),

  CONSTRAINT chk_scope_part_required
    CHECK ((scope_type <> 'PART') OR (scope_part_id IS NOT NULL)),

  CONSTRAINT chk_scope_function_required
    CHECK ((scope_type <> 'FUNCTION') OR (scope_function_desc IS NOT NULL AND length(scope_function_desc) > 0)),

  CONSTRAINT chk_no_self_approval
    CHECK (approver_id <> delegator_id)
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_delegations_project_status
  ON governance.delegations(project_id, status);

CREATE INDEX IF NOT EXISTS idx_delegations_project_delegatee
  ON governance.delegations(project_id, delegatee_id);

CREATE INDEX IF NOT EXISTS idx_delegations_project_delegator
  ON governance.delegations(project_id, delegator_id);

CREATE INDEX IF NOT EXISTS idx_delegations_scope_part
  ON governance.delegations(project_id, scope_part_id)
  WHERE scope_type = 'PART';

-- Active + time-based: frequently used partial index
CREATE INDEX IF NOT EXISTS idx_delegations_active_time
  ON governance.delegations(project_id, end_at)
  WHERE status = 'ACTIVE';

-- Re-delegation chain lookup
CREATE INDEX IF NOT EXISTS idx_delegations_parent
  ON governance.delegations(parent_delegation_id)
  WHERE parent_delegation_id IS NOT NULL;
```

**Key CHECK Constraints:**

| Constraint | Rule | Screen Reference |
|------------|------|-----------------|
| `chk_temp_end_required` | TEMPORARY must have end_at | #22 §4.5 |
| `chk_scope_part_required` | PART scope must have scope_part_id | #22 §4.5 |
| `chk_scope_function_required` | FUNCTION scope must have description | #22 §4.5.1 |
| `chk_no_self_approval` | Approver cannot be the delegator | #22 §6.2 |

**Service Layer Validations (not expressible in DDL):**

| Rule | Description | Screen Reference |
|------|-------------|-----------------|
| FUNCTION = TEMPORARY only | `scope_type='FUNCTION'` requires `duration_type='TEMPORARY'` | #22 §4.5.1 |
| FUNCTION max 90 days | `end_at - start_at <= 90` when scope_type='FUNCTION' | #22 §4.5.1 |
| Re-delegation depth max 2 | `parent_delegation_id` chain depth check | #22 §4.3.1 |
| Re-delegation PM approval | Re-delegation requires PM role holder as approver | #22 §4.3.1 |
| Cascade revoke | Revoking parent delegation cascades to children | #22 §4.3.1 |
| SoD block | severity=HIGH + category=APPROVAL = blocked | #22 §8.2 |

### 3.7 permission_audit_log (Immutable)

```sql
CREATE TABLE IF NOT EXISTS governance.permission_audit_log (
  id            UUID PRIMARY KEY,
  project_id    UUID NOT NULL,
  actor_id      UUID NOT NULL,
  action_type   TEXT NOT NULL,   -- 'GRANT_ROLE','REVOKE_ROLE','GRANT_CAP','REVOKE_CAP',
                                 -- 'CREATE_DELEGATION','REVOKE_DELEGATION','EXPIRE_DELEGATION'...
  target_type   TEXT NOT NULL,   -- 'USER_ROLE','USER_CAPABILITY','DELEGATION','ROLE','CAPABILITY'
  target_id     UUID NOT NULL,
  reason        TEXT NULL,
  payload_json  JSONB NOT NULL DEFAULT '{}'::JSONB,  -- before/after snapshot
  created_at    TIMESTAMPTZ NOT NULL DEFAULT now(),

  FOREIGN KEY (project_id) REFERENCES project.projects(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_audit_project_time
  ON governance.permission_audit_log(project_id, created_at DESC);

CREATE INDEX IF NOT EXISTS idx_audit_target
  ON governance.permission_audit_log(target_type, target_id);
```

### 3.8 sod_rules

```sql
-- SoD (Separation of Duties) rule pairs
CREATE TABLE IF NOT EXISTS governance.sod_rules (
  id              TEXT PRIMARY KEY,  -- 'SOD-001', 'SOD-002'...
  capability_a_id UUID NOT NULL,
  capability_b_id UUID NOT NULL,
  description     TEXT NOT NULL,
  severity        TEXT NOT NULL CHECK (severity IN ('HIGH','MEDIUM','LOW')),
  is_blocking     BOOLEAN NOT NULL DEFAULT false,

  FOREIGN KEY (capability_a_id) REFERENCES governance.capabilities(id),
  FOREIGN KEY (capability_b_id) REFERENCES governance.capabilities(id)
);

-- Unique pair regardless of order
CREATE UNIQUE INDEX IF NOT EXISTS uq_sod_pair
  ON governance.sod_rules(
    LEAST(capability_a_id, capability_b_id),
    GREATEST(capability_a_id, capability_b_id)
  );
```

**SoD Blocking Rule (v1.1):**
- `is_blocking = true` when `severity = 'HIGH'` AND both capabilities have `category = 'APPROVAL'`
- Blocking SoD violations prevent delegation/capability grant at service layer
- Non-blocking violations produce warnings in governance check results

### 3.9 governance_check_runs & governance_findings

```sql
-- Governance check execution records
CREATE TABLE IF NOT EXISTS governance.governance_check_runs (
  id            UUID PRIMARY KEY,
  project_id    UUID NOT NULL,
  checked_at    TIMESTAMPTZ NOT NULL DEFAULT now(),
  checked_by    UUID NULL,        -- NULL = scheduler-triggered, non-null = manual
  summary_json  JSONB NOT NULL DEFAULT '{}'::JSONB
);

-- Individual findings from a governance check
CREATE TABLE IF NOT EXISTS governance.governance_findings (
  id            UUID PRIMARY KEY,
  run_id        UUID NOT NULL,
  project_id    UUID NOT NULL,
  finding_type  TEXT NOT NULL CHECK (finding_type IN (
                  'SOD_VIOLATION','SELF_APPROVAL','EXPIRING_SOON',
                  'EXPIRED','DUPLICATE_CAP','ORPHAN_DELEGATION'
                )),
  severity      TEXT NOT NULL CHECK (severity IN ('HIGH','MEDIUM','LOW','INFO')),
  user_id       UUID NULL,
  delegation_id UUID NULL,
  message       TEXT NOT NULL,
  details_json  JSONB NOT NULL DEFAULT '{}'::JSONB,
  created_at    TIMESTAMPTZ NOT NULL DEFAULT now(),

  FOREIGN KEY (run_id) REFERENCES governance.governance_check_runs(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_findings_project_run
  ON governance.governance_findings(project_id, run_id);

CREATE INDEX IF NOT EXISTS idx_findings_project_type
  ON governance.governance_findings(project_id, finding_type);
```

---

## 4. Effective Capability Views

> **Core Principle**: Effective Capability is **computed, not stored**.
> Priority: Delegation(1) > Direct UserCapability(2) > Role Preset(3)

### 4.1 v_role_caps (Role-based Capabilities)

```sql
CREATE OR REPLACE VIEW governance.v_role_caps AS
SELECT
  ur.project_id,
  ur.user_id,
  rc.capability_id,
  'ROLE'::TEXT AS source_type,
  ur.role_id AS source_id
FROM governance.user_roles ur
JOIN governance.role_capabilities rc ON rc.role_id = ur.role_id;
```

### 4.2 v_direct_caps (Directly Granted)

```sql
CREATE OR REPLACE VIEW governance.v_direct_caps AS
SELECT
  uc.project_id,
  uc.user_id,
  uc.capability_id,
  'DIRECT'::TEXT AS source_type,
  uc.id AS source_id
FROM governance.user_capabilities uc;
```

### 4.3 v_delegated_caps (Delegation-based, Time-Aware)

```sql
CREATE OR REPLACE VIEW governance.v_delegated_caps AS
SELECT
  d.project_id,
  d.delegatee_id AS user_id,
  d.capability_id,
  'DELEGATION'::TEXT AS source_type,
  d.id AS source_id
FROM governance.delegations d
WHERE d.status = 'ACTIVE'
  AND d.start_at <= current_date
  AND (d.duration_type = 'PERMANENT' OR d.end_at >= current_date);
```

### 4.4 v_effective_caps (Priority-Applied Final View)

```sql
-- Effective Capabilities with priority: DELEGATION(1) > DIRECT(2) > ROLE(3)
-- Uses DISTINCT ON to select highest priority source per (project, user, capability)
CREATE OR REPLACE VIEW governance.v_effective_caps AS
SELECT DISTINCT ON (project_id, user_id, capability_id)
  project_id, user_id, capability_id, source_type, source_id
FROM (
  SELECT * FROM governance.v_delegated_caps
  UNION ALL
  SELECT * FROM governance.v_direct_caps
  UNION ALL
  SELECT * FROM governance.v_role_caps
) s
ORDER BY project_id, user_id, capability_id,
  CASE source_type
    WHEN 'DELEGATION' THEN 1
    WHEN 'DIRECT' THEN 2
    WHEN 'ROLE' THEN 3
    ELSE 9
  END;
```

**Usage Scenarios:**

| Query | View | Purpose |
|-------|------|---------|
| "What can this user do?" | `v_effective_caps` | Final effective capability list per user |
| "Why does this user still have access after delegation revocation?" | `v_effective_caps` | Shows remaining Direct/Role sources |
| "Duplicate capabilities" | Compare raw UNION vs `v_effective_caps` | Governance duplicate detection |
| "SoD check" | `v_effective_caps` | SoD violation detection against effective set |

---

## 5. Neo4j Graph Model (Projection)

> Neo4j serves as a **read-only projection** of Postgres data.
> The "truth" is always in Postgres. Neo4j provides fast graph traversal for visualization.

### 5.1 Node Labels

| Label | Key Properties | Source Table |
|-------|---------------|-------------|
| `:Project` | `{id}` | `project.projects` |
| `:User` | `{id, name}` | `auth.users` |
| `:Part` | `{id, name, type, status}` | `organization.parts` |
| `:Role` | `{id, code, name}` | `governance.roles` |
| `:Capability` | `{id, code, name, category}` | `governance.capabilities` |

### 5.2 Relationship Types

| Relationship | Direction | Properties | Source |
|-------------|-----------|-----------|--------|
| `(u)-[:PRIMARY_PM_OF]->(p:Project)` | User→Project | - | `governance.project_accountability` |
| `(u)-[:CO_PM_OF]->(p:Project)` | User→Project | - | `governance.project_accountability` |
| `(u)-[:SPONSOR_OF]->(p:Project)` | User→Project | - | `governance.project_accountability` |
| `(part)-[:IN_PROJECT]->(project)` | Part→Project | - | `organization.parts` |
| `(u)-[:MEMBER_OF]->(part)` | User→Part | `{type: 'PRIMARY'\|'SECONDARY'}` | `organization.part_memberships` |
| `(u)-[:LEADS]->(part)` | User→Part | - | `organization.parts.leader_user_id` |
| `(u)-[:CO_LEADS]->(part)` | User→Part | - | `organization.part_co_leaders` |
| `(u)-[:HAS_ROLE]->(role)` | User→Role | `{projectId}` | `governance.user_roles` |
| `(role)-[:INCLUDES]->(cap)` | Role→Capability | - | `governance.role_capabilities` |
| `(u)-[:HAS_DIRECT_CAP]->(cap)` | User→Capability | `{projectId}` | `governance.user_capabilities` |
| `(from)-[:DELEGATED]->(to:User)` | User→User | `{delegationId, projectId, capabilityId, scopeType, scopeId, startAt, endAt, status}` | `governance.delegations` |

**Design Decision**: Delegation is modeled as a **User-to-User edge** with `capabilityId` as a property.
This makes tree/graph visualization simpler (vs. intermediate nodes).

### 5.3 Constraints & Indexes (Neo4j 5+)

```cypher
-- Uniqueness constraints
CREATE CONSTRAINT project_id_unique IF NOT EXISTS
FOR (p:Project) REQUIRE p.id IS UNIQUE;

CREATE CONSTRAINT user_id_unique IF NOT EXISTS
FOR (u:User) REQUIRE u.id IS UNIQUE;

CREATE CONSTRAINT part_id_unique IF NOT EXISTS
FOR (t:Part) REQUIRE t.id IS UNIQUE;

CREATE CONSTRAINT role_id_unique IF NOT EXISTS
FOR (r:Role) REQUIRE r.id IS UNIQUE;

CREATE CONSTRAINT cap_id_unique IF NOT EXISTS
FOR (c:Capability) REQUIRE c.id IS UNIQUE;

-- Relationship property indexes
CREATE INDEX IF NOT EXISTS delegation_project_idx
FOR ()-[d:DELEGATED]-() ON (d.projectId);

CREATE INDEX IF NOT EXISTS delegation_cap_idx
FOR ()-[d:DELEGATED]-() ON (d.capabilityId);
```

---

## 6. Postgres-to-Neo4j Synchronization

### 6.1 Outbox Pattern

```sql
CREATE TABLE IF NOT EXISTS governance.outbox_events (
  id              UUID PRIMARY KEY,
  aggregate_type  TEXT NOT NULL,   -- 'DELEGATION','USER_ROLE','PART_MEMBERSHIP','ACCOUNTABILITY'
  aggregate_id    UUID NOT NULL,
  event_type      TEXT NOT NULL,   -- 'CREATED','UPDATED','REVOKED','EXPIRED'...
  project_id      UUID NOT NULL,
  payload         JSONB NOT NULL,
  created_at      TIMESTAMPTZ NOT NULL DEFAULT now(),
  processed_at    TIMESTAMPTZ NULL
);

CREATE INDEX IF NOT EXISTS idx_outbox_unprocessed
  ON governance.outbox_events(processed_at)
  WHERE processed_at IS NULL;
```

### 6.2 Sync Flow

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│   Service Layer  │     │  Outbox Worker   │     │     Neo4j       │
│                  │     │  (Scheduler)     │     │                 │
│  1. Write to     │     │                  │     │                 │
│     Postgres     │     │  2. Poll         │     │                 │
│     (within TX)  │────▶│     unprocessed  │────▶│  3. MERGE       │
│                  │     │     events       │     │     (idempotent) │
│  1a. Insert      │     │                  │     │                 │
│      outbox      │     │  4. Mark         │     │                 │
│      event       │     │     processed_at │     │                 │
│      (same TX)   │     │                  │     │                 │
└─────────────────┘     └─────────────────┘     └─────────────────┘
```

### 6.3 Neo4j Upsert Examples

**Delegation Created:**
```cypher
MERGE (from:User {id: $delegatorId})
MERGE (to:User {id: $delegateeId})
MERGE (p:Project {id: $projectId})
MERGE (from)-[d:DELEGATED {delegationId: $delegationId}]->(to)
SET d.projectId = $projectId,
    d.capabilityId = $capabilityId,
    d.scopeType = $scopeType,
    d.scopeId = $scopeId,
    d.startAt = $startAt,
    d.endAt = $endAt,
    d.status = $status,
    d.updatedAt = timestamp();
```

**Delegation Revoked/Expired:**
```cypher
MATCH ()-[d:DELEGATED {delegationId: $delegationId}]->()
SET d.status = $newStatus,
    d.updatedAt = timestamp();
```

> **Note**: Revoked/Expired delegations update `status` property instead of deleting the relationship.
> This preserves the graph for audit visualization and historical traversal.

**Accountability Changed:**
```cypher
// Remove old PM relationship
MATCH (oldPm:User)-[r:PRIMARY_PM_OF]->(p:Project {id: $projectId})
DELETE r;

// Create new PM relationship
MERGE (newPm:User {id: $newPmId})
MERGE (p:Project {id: $projectId})
MERGE (newPm)-[:PRIMARY_PM_OF]->(p);
```

---

## 7. Key Queries

### 7.1 Effective Capabilities for a User (Postgres)

```sql
-- #22 screen: User detail panel > Effective Capabilities
SELECT c.code, c.name, c.category, e.source_type
FROM governance.v_effective_caps e
JOIN governance.capabilities c ON c.id = e.capability_id
WHERE e.project_id = :projectId
  AND e.user_id = :userId
ORDER BY c.category, c.code;
```

### 7.2 Delegation Map (Neo4j)

```cypher
-- #22 screen: Tab 1 Delegation Map (PM as root, tree traversal)
MATCH (pm:User)-[:PRIMARY_PM_OF]->(p:Project {id: $projectId})
MATCH path = (pm)-[:DELEGATED*0..5 {projectId: $projectId}]->(u:User)
RETURN path;
```

With expiring delegation filter:
```cypher
MATCH (pm:User)-[:PRIMARY_PM_OF]->(p:Project {id: $projectId})
MATCH path = (pm)-[:DELEGATED*0..5 {projectId: $projectId}]->(u:User)
WHERE ALL(r IN relationships(path) WHERE r.status = 'ACTIVE')
RETURN path;
```

### 7.3 Expiring Delegations (Postgres)

```sql
-- #22 screen: Governance tab > Expiring soon (D-7)
SELECT id, delegator_id, delegatee_id, capability_id, end_at
FROM governance.delegations
WHERE project_id = :projectId
  AND status = 'ACTIVE'
  AND duration_type = 'TEMPORARY'
  AND end_at <= (current_date + 7);
```

### 7.4 SoD Violations (Postgres)

```sql
-- #22 screen: Governance tab > SoD violations based on effective capabilities
WITH user_caps AS (
  SELECT project_id, user_id, capability_id
  FROM governance.v_effective_caps
  WHERE project_id = :projectId
),
pairs AS (
  SELECT
    uc.user_id,
    r.id AS rule_id,
    r.description,
    r.severity,
    r.is_blocking,
    r.capability_a_id,
    r.capability_b_id
  FROM governance.sod_rules r
  JOIN user_caps a ON a.capability_id = r.capability_a_id
  JOIN user_caps b ON b.capability_id = r.capability_b_id
                  AND a.user_id = b.user_id
  JOIN (SELECT DISTINCT user_id FROM user_caps) uc ON uc.user_id = a.user_id
)
SELECT * FROM pairs;
```

### 7.5 Connection Summary for #20 Screen (Postgres)

```sql
-- #20 screen: Read-only connection info (part count, user count, delegation count)
SELECT
  p.id AS project_id,
  (SELECT count(*) FROM organization.parts pt WHERE pt.project_id = p.id AND pt.status = 'ACTIVE') AS part_count,
  (SELECT count(DISTINCT pm.user_id) FROM organization.part_memberships pm WHERE pm.project_id = p.id AND pm.left_at IS NULL) AS total_user_count,
  (SELECT count(*) FROM governance.delegations d WHERE d.project_id = p.id AND d.status = 'ACTIVE') AS active_delegation_count
FROM project.projects p
WHERE p.id = :projectId;
```

### 7.6 Part Leader Delegation Warning for #21 Screen (Postgres)

```sql
-- #21 screen: Check if part leader has required delegated capabilities
WITH required_caps AS (
  -- This would come from PartLeaderRequiredCaps configuration
  -- Example for AI_DEVELOPMENT: approve_code, assign_task
  SELECT unnest(ARRAY['approve_code', 'assign_task']) AS cap_code
),
leader_delegated_caps AS (
  SELECT c.code
  FROM governance.v_delegated_caps dc
  JOIN governance.capabilities c ON c.id = dc.capability_id
  WHERE dc.project_id = :projectId
    AND dc.user_id = :leaderUserId
)
SELECT rc.cap_code AS missing_cap
FROM required_caps rc
LEFT JOIN leader_delegated_caps ldc ON ldc.code = rc.cap_code
WHERE ldc.code IS NULL;
```

---

## 8. Scheduler: Delegation Expiration

### 8.1 Daily Expiration Job

```sql
-- Run daily at 00:00 KST (Asia/Seoul)
-- Step 1: Expire delegations past end_at
UPDATE governance.delegations
SET status = 'EXPIRED'
WHERE status = 'ACTIVE'
  AND duration_type = 'TEMPORARY'
  AND end_at < current_date;
```

### 8.2 Post-Expiration Flow

```
Daily 00:00 KST
    │
    ▼
┌────────────────────────────┐
│  UPDATE status='EXPIRED'   │
│  WHERE end_at < today      │
└────────────┬───────────────┘
             │
             ▼
┌────────────────────────────┐
│  INSERT outbox_events      │
│  for each expired          │
│  delegation                │
└────────────┬───────────────┘
             │
             ▼
┌────────────────────────────┐
│  Outbox Worker picks up    │
│  EXPIRED events            │
│  → Neo4j: SET status       │
└────────────┬───────────────┘
             │
             ▼
┌────────────────────────────┐
│  Cascade: Check for        │
│  child re-delegations      │
│  (parent expired           │
│   → children also expire)  │
└────────────────────────────┘
```

---

## 9. Entity Relationship Diagram (Consolidated)

```
┌─────────────────────────────────────────────────────────────────┐
│  POSTGRES (SoT)                                                  │
│                                                                   │
│  ┌─── governance schema ───────────────────────────────────────┐ │
│  │                                                              │ │
│  │  project_accountability ←──FK── accountability_change_log    │ │
│  │       (#20)                         (#20)                    │ │
│  │                                                              │ │
│  │  roles ──M:N── capabilities                                  │ │
│  │    │    (role_capabilities)                                   │ │
│  │    │                                                         │ │
│  │  user_roles         user_capabilities                        │ │
│  │    │                    │                                    │ │
│  │    │    ┌───────────────┘                                    │ │
│  │    │    │                                                    │ │
│  │    ▼    ▼                                                    │ │
│  │  ┌──────────────────┐                                        │ │
│  │  │ v_effective_caps │ ← computed from 3 sources               │ │
│  │  └──────────────────┘                                        │ │
│  │                                                              │ │
│  │  delegations ──FK── capabilities                             │ │
│  │       │         ──FK── parts (scope)                         │ │
│  │       │         ──self── delegations (re-delegation chain)   │ │
│  │       │                                                      │ │
│  │  sod_rules ──FK── capabilities (pair)                        │ │
│  │                                                              │ │
│  │  governance_check_runs ──1:N── governance_findings           │ │
│  │                                                              │ │
│  │  permission_audit_log  (append-only)                         │ │
│  │  outbox_events         (sync to Neo4j)                       │ │
│  └──────────────────────────────────────────────────────────────┘ │
│                                                                   │
│  ┌─── organization schema ─────────────────────────────────────┐ │
│  │                                                              │ │
│  │  parts ──1:N── part_memberships                              │ │
│  │    │                                                         │ │
│  │    ├── part_co_leaders                                       │ │
│  │    │                                                         │ │
│  │  assignment_change_log (audit)                               │ │
│  └──────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  NEO4J (Projection)                                              │
│                                                                   │
│  (:User)──[:PRIMARY_PM_OF]──>(:Project)                          │
│  (:User)──[:MEMBER_OF]──>(:Part)──[:IN_PROJECT]──>(:Project)     │
│  (:User)──[:LEADS/CO_LEADS]──>(:Part)                            │
│  (:User)──[:HAS_ROLE]──>(:Role)──[:INCLUDES]──>(:Capability)    │
│  (:User)──[:HAS_DIRECT_CAP]──>(:Capability)                     │
│  (:User)──[:DELEGATED {capId,scope,dates}]──>(:User)             │
│                                                                   │
│  Sync: Postgres outbox_events → Worker → Neo4j MERGE             │
└─────────────────────────────────────────────────────────────────┘
```

---

## 10. Table-to-Screen Mapping

| Table / View | Schema | Screen | Purpose |
|-------------|--------|--------|---------|
| `project_accountability` | governance | #20 | Current PM/Co-PM/Sponsor |
| `accountability_change_log` | governance | #20 | Accountability change timeline |
| `parts` | organization | #21 | Part list, detail |
| `part_co_leaders` | organization | #21 | Co-leader list |
| `part_memberships` | organization | #21 | Member assignment, Primary/Secondary |
| `assignment_change_log` | organization | #21 | Part/member change audit |
| `roles` | governance | #22 Tab 2 | Role definition |
| `capabilities` | governance | #22 Tab 2 | Capability definition |
| `role_capabilities` | governance | #22 Tab 2 | Role-preset mapping |
| `user_roles` | governance | #22 Tab 2 | Role assignment per user |
| `user_capabilities` | governance | #22 Tab 2 | Direct capability grant |
| `delegations` | governance | #22 Tab 1 | Delegation map, user detail |
| `v_effective_caps` | governance | #22 Tab 1/2 | User effective capabilities |
| `sod_rules` | governance | #22 Tab 3 | SoD rule pairs |
| `governance_check_runs` | governance | #22 Tab 3 | Governance check history |
| `governance_findings` | governance | #22 Tab 3 | Governance findings list |
| `permission_audit_log` | governance | #22 (all) | All permission change audit |
| `outbox_events` | governance | (internal) | Postgres→Neo4j sync |

---

## 11. Implementation Checkpoints

| # | Checkpoint | Caution |
|---|-----------|---------|
| 1 | Neo4j is NOT the "truth" DB | Effective capability decisions and audit evidence must always be based on Postgres results |
| 2 | Delegation Map uses Neo4j for traversal | But "is this delegation currently valid?" check uses Postgres (status + date range) |
| 3 | PART scope delegation | `scope_part_id` FK provides referential integrity in Postgres; Neo4j uses `scopeId` property for traversal only |
| 4 | Primary membership uniqueness | Enforced at DB level via partial unique index `uq_user_primary_membership` |
| 5 | "Last membership removal" | Cannot be expressed as DB constraint; must be validated at service layer within transaction |
| 6 | FUNCTION scope max 90 days | Cannot be expressed as DB CHECK (date arithmetic); validated at service layer |
| 7 | Re-delegation cascade revoke | Service layer must recursively find child delegations and revoke them |
| 8 | SoD blocking | Service layer checks `sod_rules.is_blocking` before granting capability/delegation |
| 9 | Outbox processed_at | Worker must be idempotent; Neo4j MERGE ensures duplicate processing is safe |

---

## Appendix A: Schema Creation

```sql
-- Run once to create schemas
CREATE SCHEMA IF NOT EXISTS governance;
CREATE SCHEMA IF NOT EXISTS organization;
```

## Appendix B: Aggregate Types for Outbox Events

| aggregate_type | event_type values | Trigger |
|---------------|-------------------|---------|
| `ACCOUNTABILITY` | `PM_CHANGED`, `CO_PM_CHANGED`, `SPONSOR_CHANGED` | #20 PM/Co-PM/Sponsor change |
| `PART` | `CREATED`, `CLOSED`, `REOPENED`, `LEADER_CHANGED` | #21 Part lifecycle |
| `PART_MEMBERSHIP` | `MEMBER_ADDED`, `MEMBER_REMOVED`, `PRIMARY_SWITCHED` | #21 Member assignment |
| `USER_ROLE` | `GRANTED`, `REVOKED` | #22 Role grant/revoke |
| `USER_CAPABILITY` | `GRANTED`, `REVOKED` | #22 Direct cap grant/revoke |
| `DELEGATION` | `CREATED`, `REVOKED`, `EXPIRED`, `STATUS_CHANGED` | #22 Delegation lifecycle |
