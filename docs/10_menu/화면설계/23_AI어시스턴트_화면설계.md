# 23. AI 어시스턴트 화면설계

> 작성일: 2026-02-09
> 버전: v1.1 (보강판)
> 라우트: `/ai-assistant`
> 필요 Capability: `view_ai_assistant` (진입), 액션별 개별 Capability (행동)
> 기본 Preset: `resolvePresetByRole(role)` — 역할에 따라 런타임 결정
> 노드 역할: **Hub** (허브 노드 — AI 기반 프로젝트 상태·위험·결정 지원 콘솔)

---

## 1. 화면 개요

### 1.1 목적

AI 어시스턴트 메뉴는 **"지금 프로젝트에서 주의해야 할 것은 무엇이고, 다음으로 무엇을 결정해야 하는가?"**에 대한 구조화된 답을 제공하는 **의사결정 콘솔**이다.

> **핵심 정체성**: 이 화면은 챗봇이 아니다. 이미 존재하는 오른쪽 AI 챗봇(Global AI Copilot) 위에서, 프로젝트 데이터를 **구조적으로 해석**하고, **행동 가능한 판단 단위**로 제공하며, 모든 결정은 기존 PMS 흐름으로 되돌리는 **공식 의사결정 콘솔**이다.

### 1.2 기존 AI 챗봇과의 역할 분리

| 구분 | 오른쪽 AI 챗봇 (`AIAssistant.tsx`) | 이 메뉴의 AI 콘솔 (`/ai-assistant`) |
|------|------|------|
| **호출 방식** | 사용자가 직접 호출 (Pull) | 화면 진입 시 자동 생성 (Push) |
| **중심 축** | 질문 → 답변 | 상황 → 판단 |
| **UI 형태** | 대화형 (채팅) | 대시보드형 (카드·패널) |
| **주요 목적** | 탐색·질의·학습 | 판단·결정·행동 촉진 |
| **액션 연결** | 약함 (텍스트 답변 중심) | 강함 (버튼 + 딥링크 + Capability 검증) |
| **설명 책임** | 제한적 | 필수 (근거·신뢰도·데이터 소스 명시) |
| **데이터 범위** | 사용자 질문에 따라 가변 | 프로젝트 전체 + 기간 범위 고정 |

### 1.3 설계 원칙

| 원칙 | 설명 |
|------|------|
| **챗봇이 아닌 콘솔** | 자유 입력창이 화면 중심에 오지 않는다. "무엇을 도와드릴까요?" 문구 없음 |
| **자동 생성 우선** | 화면 진입 시 AI 브리핑이 자동으로 생성되어 표시 |
| **구조화된 판단 단위** | 모든 인사이트는 개별 카드 형태, 단일 주장 + 근거 + 행동 버튼 |
| **역할 기반 관점 전환** | 동일 데이터를 PM·PMO·DEV 역할에 따라 다른 관점으로 해석 |
| **행동 연결 필수** | 모든 인사이트에는 Capability 검증을 통과한 실행 버튼이 포함 |
| **설명 책임(Explainability)** | 기준 시점·사용 데이터·신뢰도·누락 경고를 항상 확인 가능 |
| **AI는 추천자, 인간은 결정자** | AI가 직접 데이터를 변경하지 않음. 기존 PMS 화면으로 이동하여 사용자가 실행 |
| **스냅샷 일관성** | 모든 브리핑/인사이트 근거는 동일 `asOf` 스냅샷 기준으로 계산된다. 브리핑 10:30 기준인데 근거가 10:32 데이터를 가리키는 일이 없어야 한다 |
| **완결성 표시** | AI 브리핑은 데이터 완결성(`completeness`)을 항상 표기하며, `PARTIAL`일 경우 경고와 누락 항목을 명시한다 |

### 1.4 이 메뉴에 포함하지 않는 것

| 금지 요소 | 사유 |
|-----------|------|
| 자유 채팅 입력창 | 오른쪽 챗봇의 영역 |
| "무엇을 도와드릴까요?" 문구 | 이 화면은 Push형이며 AI가 먼저 정보를 제공 |
| 감성형/농담/잡담 응답 | 의사결정 콘솔의 신뢰성 훼손 |
| 외부 검색 기능 | PMS 내부 데이터만 사용 |
| 직접 CRUD 기능 | 기존 화면으로 이동하여 실행 |

### 1.5 Capability 2계층 분리 — 진입 권한 vs 행동 권한

이 화면은 2종류의 Capability가 동시에 작동한다. 혼동하면 "버튼은 보이는데 누르면 403" 또는 "버튼이 아예 안 보임" 버그가 발생한다.

| 계층 | Capability | 적용 지점 | 설명 |
|------|-----------|----------|------|
| **진입 권한** | `view_ai_assistant` | 메뉴 노출, 라우트 가드 | 이 화면에 접근할 수 있는가? |
| **행동 권한** | `manage_issues`, `manage_risks`, `manage_tasks`, `manage_meetings`, `manage_pmo`, `manage_governance`, `manage_deliverables`, `update_own_tasks` | 액션 버튼 렌더링, 딥링크 대상 화면 Route Guard | 특정 행동을 실행할 수 있는가? |

**이중 보호 구조:**

```
1. 프론트엔드 CapabilityGuard → 버튼 렌더링 여부 결정
2. 딥링크 대상 화면의 Route Guard → 실제 접근 재검증
```

> `view_ai_assistant`는 "콘솔에 들어올 수 있는가", 액션 Capability는 "행동을 실행할 수 있는가". 둘을 문서/코드/테스트에서 항상 분리 유지한다.

---

## 2. MenuOntology 노드

### 2.1 노드 정의 (v1.1 갱신)

```typescript
export const aiAssistantNode: MenuOntologyNode = {
  nodeId: 'ai-assistant',
  label: 'AI 어시스턴트',
  route: '/ai-assistant',
  icon: 'Bot',
  domain: 'tools',
  nodeRole: 'hub',              // v1.1: AI 스코어링 허브 페널티 적용
  requiredCaps: ['view_ai_assistant'],
  intents: [
    'ask_overall_status',
    'ask_progress',
    'ask_bottleneck',
    'ask_risk',
    'ask_my_work',
    'review_ai_briefing',       // v1.1
    'check_ai_insights',        // v1.1
    'view_recommended_actions',  // v1.1
  ],
  canonicalQuestions: [
    'AI 어시스턴트를 열어주세요.',
    'AI에게 질문하고 싶어요.',
    '프로젝트에 대해 물어보고 싶어요.',
    '이번 주 프로젝트 요약 보여줘.',    // v1.1
    '리스크 분석 결과는?',              // v1.1
  ],
  entities: ['Project', 'Task', 'Issue', 'Sprint', 'Risk'],  // v1.1: PascalCase 정규화
  keywords: [
    'AI', '어시스턴트', 'assistant', '챗봇', 'chatbot',
    '질문', 'question', '도움', 'help', '분석',
    '브리핑', 'briefing', '인사이트', 'insight',  // v1.1
  ],
  // v1.1: defaultPreset은 fallback 전용. 런타임에서 resolvePresetByRole(role)로 확정
  defaultPreset: 'PM_WORK',
  presetPolicies: [
    {
      preset: 'EXEC_SUMMARY',
      ui: { density: 'compact', defaultRightPanel: 'closed' },
    },
    {
      preset: 'PMO_CONTROL',
      ui: { density: 'standard', defaultRightPanel: 'open' },
    },
    {
      preset: 'PM_WORK',
      ui: { density: 'detailed', defaultRightPanel: 'open' },
    },
    {
      preset: 'DEV_EXECUTION',
      ui: { density: 'standard', defaultRightPanel: 'closed' },
    },
  ],
  priority: 21,
  // v1.1: scopeHints 확장 — 브리핑 범위 결정에 필요한 컨텍스트
  scopeHints: ['projectId', 'sprintId?', 'phaseId?', 'asOf?'],
};
```

### 2.2 Preset 런타임 결정 로직

`defaultPreset`은 fallback 전용이다. 실제 진입 시에는 다음 로직으로 확정한다:

```typescript
function resolvePresetByRole(role: string): PresetKey {
  switch (role) {
    case 'sponsor':       return 'EXEC_SUMMARY';
    case 'pmo_head':      return 'PMO_CONTROL';
    case 'pm':            return 'PM_WORK';
    case 'developer':
    case 'qa':            return 'DEV_EXECUTION';
    default:              return 'PM_WORK'; // fallback
  }
}
```

> Sponsor/PMO가 들어왔을 때 `PM_WORK`가 적용되는 버그를 방지한다.

### 2.3 Scope 결정 정책

URL을 복잡하게 만들지 않기 위해, 기본 scope는 서버가 결정한다:

| 조건 | 기본 scope | URL 예시 |
|------|-----------|---------|
| 활성 스프린트 존재 | `current_sprint` | `/ai-assistant` |
| 활성 스프린트 없음 | `last_7_days` | `/ai-assistant` |
| 사용자 수동 변경 | 선택값 | `/ai-assistant?scope=current_phase` |

```typescript
type BriefingScope = 'current_sprint' | 'last_7_days' | 'last_14_days' | 'current_phase';
```

---

## 3. 화면 레이아웃

### 3.1 전체 구조 (Top → Bottom)

```
┌──────────────────────────────────────────────────────────┐
│ [A] AI Context Header — 프로젝트, 역할, 기준시점, 범위    │
│     + 완결성 표시 (FULL / PARTIAL / UNKNOWN)              │
├──────────────────────────────────────────────────────────┤
│ [B] AI Briefing Panel — 자동 생성 요약 (3~5줄)           │
│     (변화 감지 신호 + 전체 상태 지표)                     │
├──────────────────────────────────────────────────────────┤
│ [C] Insight Card List — 유형별 인사이트 카드              │
│     (Risk / Delay / Bottleneck / Policy Gap)             │
├──────────────────────────────────────────────────────────┤
│ [D] Recommended Action Panel — 지금 할 수 있는 행동       │
│     (Capability 검증 통과한 액션만 표시)                   │
├──────────────────────────────────────────────────────────┤
│ [E] Explainability Drawer — 기본 접힘, 필요 시 펼침       │
│     (기준시점, 데이터소스, 신뢰도, 완결성, 누락경고)       │
└──────────────────────────────────────────────────────────┘
```

### 3.2 각 영역 상세

#### [A] AiContextHeader — AI 판단 맥락 표시

| 표시 항목 | 설명 | 예시 |
|-----------|------|------|
| 프로젝트명 | 현재 선택된 프로젝트 | `보험심사 시스템 구축` |
| 사용자 역할 | 현재 로그인 사용자의 역할 | `PM` / `PMO` / `Developer` |
| 기준 시점 (asOf) | AI 데이터 수집 기준 시각 | `2026-02-09 10:30 KST` |
| 데이터 범위 (scope) | 분석 대상 기간 / 스코프 | `현재 스프린트` / `최근 7일` |
| **완결성 배지** | 데이터 완결성 상태 | 🟢 `FULL` / 🟡 `PARTIAL` / ⚪ `UNKNOWN` |
| 새로고침 버튼 | 수동으로 AI 브리핑 재생성 | `↻ 브리핑 갱신` |
| Scope 변경 드롭다운 | 분석 범위 수동 변경 | `현재 스프린트` / `최근 7일` / `현재 단계` |

> **"이 AI 판단은 언제, 누구 기준으로, 어떤 범위의 데이터를 사용했고, 데이터가 완전한가?"**를 항상 명시

#### [B] AiBriefingPanel — 자동 생성 프로젝트 요약

이 화면에 진입하는 순간, 입력창보다 먼저 보여야 하는 핵심 영역이다.

| 구성 요소 | 설명 |
|-----------|------|
| **헤드라인** | 핵심 메시지 1문장 (예: "이번 스프린트는 일정 지연 위험이 있습니다") |
| **감지 신호** | 변화 태그 목록 (예: `SCHEDULE_DELAY`, `TEST_GAP`, `RESOURCE_BOTTLENECK`) |
| **상태 지표** | 전체 건강도 시각 표시 (🟢 정상 / 🟡 주의 / 🔴 위험) |
| **신뢰도** | 이 요약의 AI 신뢰도 수치 (예: `87%`) |
| **완결성 경고** | `PARTIAL`일 경우 경고 배너 표시 (예: "최근 3일간 커밋 데이터 누락으로 분석이 불완전합니다") |
| **요약 본문** | 3~5줄 구조화 텍스트 — 대시보드 숫자를 문장으로 번역 |

> **챗봇이 절대 잘 못하는 영역**: "정기적·구조적 요약"은 전용 화면이 필요하다

**역할별 브리핑 관점 전환:**

| 역할 | 브리핑 초점 |
|------|-----------|
| **PM** | 실행 지연, 담당자 병목, 스프린트 안정성, 미해결 이슈 |
| **PMO** | 프로젝트 간 편차, 위험 집중 구간, 통제 포인트, 감사 대비 상태 |
| **Sponsor** | 전체 진행률, 예산 소진율, 핵심 마일스톤 도달 여부 |
| **Developer** | 내 담당 작업 현황, 블로커 유무, 코드 리뷰 대기 건 |
| **QA** | 테스트 커버리지 변화, 실패 테스트 추이, 릴리스 품질 지표 |

> 동일 데이터, 다른 해석 — "대화"로 하면 품질이 떨어지고, **사전 설계된 AI 시점(View)**이 필요

#### [C] InsightCardList — 유형별 인사이트 카드

각 카드는 **독립적 판단 단위**이며, 반드시 다음 구조를 따른다:

```
┌─────────────────────────────────────────────────┐
│ [심각도 배지]  [유형 라벨]        [신뢰도 87%]   │
│                                                  │
│ 제목: 결제 모듈 작업 지연                         │
│                                                  │
│ 설명: 3개 태스크가 예정일을 초과했으며             │
│       모두 동일 담당자에게 할당됨                  │
│                                                  │
│ 근거: overdue_tasks=3, assignee=홍길동            │
│       데이터 소스: PostgreSQL task 테이블          │
│       기준 시점: 2026-02-09 10:30 KST            │
│                                                  │
│ ┌────────────────┐ ┌──────────────────────────┐  │
│ │ 리스크 등록     │ │ 이 내용에 대해 질문하기  │  │
│ └────────────────┘ └──────────────────────────┘  │
└─────────────────────────────────────────────────┘
```

**인사이트 유형:**

| 유형 코드 | 라벨 | 설명 | 배지 색상 |
|-----------|------|------|----------|
| `DELAY` | 일정 지연 | 태스크/마일스톤 예정일 초과 | 🔴 빨강 |
| `RISK` | 리스크 감지 | 식별된 위험 요소 | 🟠 주황 |
| `BOTTLENECK` | 병목 감지 | 특정 담당자/파트에 업무 집중 | 🟡 노랑 |
| `POLICY_GAP` | 정책 위반 | SoD 위반, 권한 미할당 등 | 🔴 빨강 |
| `QUALITY` | 품질 경고 | 테스트 실패율 증가, 커버리지 하락 | 🟠 주황 |
| `PROGRESS` | 진행률 변화 | 예상 대비 진행률 편차 | 🔵 파랑 |
| `RESOURCE` | 리소스 이상 | 과할당, 미할당, 역할 공백 | 🟡 노랑 |
| `POSITIVE` | 긍정 신호 | 일정 앞당김, 품질 개선 등 | 🟢 초록 |

#### [D] RecommendedActionPanel — 행동 추천

이 메뉴의 AI 인사이트는 항상 **행동으로 끝나야** 한다.

| 행동 | 연결 화면 | 필요 Capability |
|------|----------|----------------|
| 이슈 생성 | `/issues` → 신규 등록 | `manage_issues` |
| 리스크 등록 | `/decision-risk` → 리스크 탭 | `manage_risks` |
| PMO 에스컬레이션 | `/pmo-console` → 에스컬레이션 | `manage_pmo` |
| 회의 안건 생성 | `/meetings` → 신규 등록 | `manage_meetings` |
| 작업 재할당 | `/kanban` → 벌크 할당 | `manage_tasks` |
| 거버넌스 점검 실행 | `/role-permission` → 거버넌스 탭 | `manage_governance` |

> **이중 Capability 검증**: 프론트에서 `CapabilityGuard`로 버튼 렌더링 여부를 결정하고, 딥링크 대상 화면의 `Route Guard`가 실제 접근을 재검증한다. (§1.5 참조)

#### [E] ExplainabilityDrawer — AI 판단 근거 패널

기본 **접힘** 상태. 필요할 때 열어서 확인하는 구조.

| 항목 | 설명 |
|------|------|
| **기준 시점** (as-of) | AI가 데이터를 수집한 정확한 시각 |
| **데이터 완결성** | `FULL` / `PARTIAL` / `UNKNOWN` + 누락 항목 명시 |
| **사용 데이터 소스** | PostgreSQL, Neo4j, Redis 등 어떤 소스를 조회했는지 |
| **누락 경고** | 데이터 불완전 시 구체적 경고 (예: "최근 3일 커밋 데이터 누락", "Neo4j 동기화 12분 지연") |
| **인사이트별 근거 상세** | 각 인사이트가 참조한 엔티티 ID, 메트릭 값, 쿼리 결과 |
| **최근 변경 이력 링크** | `/lineage/:entityType/:entityId` 형태의 Trace Link 바로가기 |
| **생성 방식** | Rule-based / Model-based / Hybrid 표시 |

> 오른쪽 챗봇에 Explainability를 다 넣으면 UX가 무너진다. **이 메뉴가 AI 설명 책임의 공식 장소**

---

## 4. AI 브리핑 카드 표준 스키마

### 4.1 전체 응답 구조

이 스키마는 챗봇과 공용으로 쓰지 않는다. **결정용 AI 응답 전용** 포맷이다.

```typescript
interface AiBriefingResponse {
  /** AI 판단 맥락 */
  context: {
    projectId: string;
    role: string;            // PM | PMO | DEV | QA | SPONSOR
    asOf: string;            // ISO 8601 (예: "2026-02-09T10:30:00+09:00")
    scope: BriefingScope;    // "current_sprint" | "last_7_days" | "current_phase"
    /** v1.1: 데이터 완결성 — PARTIAL일 경우 missingSignals 확인 필수 */
    completeness: 'FULL' | 'PARTIAL' | 'UNKNOWN';
    /** v1.1: 누락된 데이터 신호 목록 */
    missingSignals?: string[];  // ["commits_last_3d", "qa_test_runs", "neo4j_sync"]
  };

  /** 프로젝트 요약 */
  summary: {
    headline: string;        // 핵심 메시지 1문장
    signals: string[];       // 감지된 신호 태그 목록
    healthStatus: 'GREEN' | 'YELLOW' | 'RED';
    confidence: number;      // 0.0 ~ 1.0
    body: string;            // 3~5줄 요약 본문
  };

  /** 개별 인사이트 목록 */
  insights: AiInsight[];

  /** 추천 행동 목록 */
  recommendedActions: AiRecommendedAction[];

  /** 설명 책임 메타데이터 */
  explainability: AiExplainability;
}

type BriefingScope = 'current_sprint' | 'last_7_days' | 'last_14_days' | 'current_phase';
```

### 4.2 개별 인사이트 스키마

```typescript
interface AiInsight {
  id: string;                // "insight-delay-01"
  type: InsightType;         // DELAY | RISK | BOTTLENECK | POLICY_GAP | QUALITY | PROGRESS | RESOURCE | POSITIVE
  severity: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW' | 'INFO';
  title: string;             // "결제 모듈 작업 지연"
  description: string;       // "3개 태스크가 예정일을 초과..."
  confidence: number;        // 0.0 ~ 1.0

  /** 판단 근거 */
  evidence: {
    /** v1.1: 이 근거의 기준 시점 — 반드시 briefing.context.asOf와 동일해야 함 */
    asOf: string;            // ISO 8601 (briefing.context.asOf 복제)
    metrics: string[];       // ["overdue_tasks=3", "avg_delay_days=4.2"]
    entities: string[];      // ["task-101", "task-104", "task-107"]
    dataSource: string;      // "PostgreSQL" | "Neo4j" | "Redis"
    query?: string;          // 참조된 쿼리 (선택적)
  };

  /** 연결 가능한 행동 목록 */
  actionRefs: string[];      // recommendedActions의 actionId 참조
}
```

> **v1.1 스냅샷 일관성 강제**: `evidence.asOf`는 반드시 `briefing.context.asOf`와 동일한 값이어야 한다. 서버에서 브리핑 생성 시 `asOf`를 고정하고, 모든 evidence 쿼리가 그 시점 기준으로 동작한다. 이를 통해 "브리핑은 10:30 기준인데 근거는 10:32 데이터" 같은 불일치를 방지한다.

> **중요 설계 포인트:**
> - 모든 인사이트는 **단일 주장** (하나의 카드 = 하나의 판단)
> - 모든 주장에는 **근거(evidence) 필수**
> - `confidence < 0.6` → "참고용" 표시 + 약화된 스타일 렌더링
> - 이것이 없으면 AI는 의견이 된다. 이것이 있으면 AI는 판단 근거가 된다

### 4.3 추천 행동 스키마

```typescript
interface AiRecommendedAction {
  actionId: string;          // "create-risk"
  label: string;             // "리스크로 등록"
  description: string;       // "감지된 지연 패턴을 리스크 보드에 등록합니다"
  requiredCapability: string; // "manage_risks"
  targetRoute: string;       // "/decision-risk?tab=risk&action=new&sourceInsight=insight-delay-01"
  priority: number;          // 1 = 가장 우선
  sourceInsightIds: string[]; // 이 행동을 생성한 인사이트 ID들
}
```

### 4.4 설명 책임 스키마

```typescript
interface AiExplainability {
  /** 데이터 수집 시점 */
  dataCollectedAt: string;   // ISO 8601

  /** v1.1: 데이터 완결성 — "이 답이 완전한가?" */
  completeness: 'FULL' | 'PARTIAL' | 'UNKNOWN';

  /** v1.1: 누락된 데이터 신호 (completeness가 PARTIAL일 때 필수) */
  missingSignals: string[];  // ["commits_last_3d", "qa_test_runs"]

  /** 사용된 데이터 소스 목록 */
  dataSources: {
    source: string;          // "PostgreSQL" | "Neo4j" | "Redis"
    tables?: string[];       // ["project.tasks", "project.sprints"]
    recordCount?: number;    // 조회된 레코드 수
    /** v1.1: 이 소스의 데이터 신선도 */
    lastSyncAt?: string;     // ISO 8601 — 마지막 동기화 시각
  }[];

  /** 생성 방식 */
  generationMethod: 'RULE_BASED' | 'MODEL_BASED' | 'HYBRID';

  /** 누락/경고 */
  warnings: string[];        // ["최근 3일간 커밋 데이터 없음", "Neo4j 동기화 12분 지연"]

  /** 관련 변경 이력 링크 — Lineage 화면으로 딥링크 */
  changeHistoryLinks: {
    label: string;
    route: string;           // v1.1: "/lineage/:entityType/:entityId" 형태
  }[];
}
```

> **v1.1 추가**: `completeness`와 `missingSignals`가 있으면 PMO/감사 대응에서 "AI가 왜 조심스럽게 말했는지"를 설명하기 쉬워진다. 운영에서 가장 자주 나오는 질문은 "이거 믿어도 되나?"이며, 이 필드가 그 답을 제공한다.

---

## 5. 챗봇 ↔ AI 콘솔 컨텍스트 연결 프로토콜

### 5.1 역할 관계

```
┌─────────────────────┐
│  AI 콘솔 (이 메뉴)   │  ← AI 판단의 "결과" (구조화)
│  /ai-assistant       │
│                     │     "이 내용에 대해 질문하기" 버튼
│                     │              │
│                     │              ▼
│                     │  ┌───────────────────────┐
│                     │  │ 오른쪽 AI 챗봇         │  ← AI 판단의 "확장 질의"
│                     │  │ (Global AI Copilot)    │
│                     │  └───────────────────────┘
└─────────────────────┘
```

**관계 정의:**
- AI 콘솔 = **지휘** (구조화된 판단 제공)
- AI 챗봇 = **대화** (인사이트에 대한 후속 질의)
- AI 콘솔이 챗봇을 대체하지 않는다. **지휘한다.**

### 5.2 연결 방식 (UX 흐름)

각 인사이트 카드 우측에 `[이 내용에 대해 질문하기]` 버튼 배치.

**클릭 시 동작:**

```typescript
// 인사이트 카드 내 버튼 클릭 핸들러
function handleAskAboutInsight(insight: AiInsight) {
  openAiChatPanel({
    mode: 'CONTEXTUAL',
    injectedContext: {
      insightId: insight.id,
      insightType: insight.type,
      insightTitle: insight.title,
      projectId: currentProject.id,
      asOf: briefing.context.asOf,
      evidenceRef: insight.evidence.entities,
      summary: insight.description,
    },
  });
}
```

**챗봇 수신 처리:**

```typescript
// AIAssistant.tsx (오른쪽 챗봇)에서 injectedContext를 수신하면:
// 1. 패널 자동 열림
// 2. 시스템 메시지로 컨텍스트 주입
// 3. 사용자에게 "해당 인사이트에 대해 질문해 주세요" 안내
const contextMessage = `[AI 콘솔 컨텍스트] "${insight.insightTitle}"에 대한 질의입니다. ` +
  `관련 엔티티: ${insight.evidenceRef.join(', ')}. ` +
  `기준 시점: ${insight.asOf}`;
```

### 5.3 챗봇에서 허용되는 질문 범위

| 허용 | 비허용 |
|------|--------|
| "왜 지연이라고 판단했어?" | "이걸 무시해도 될까?" |
| "이 리스크를 줄이려면?" | "임의로 일정을 변경해 줘" |
| "담당자 변경의 영향은?" | "자동으로 재할당해 줘" |
| "유사 사례가 있었나?" | "과거 데이터를 삭제해 줘" |

> **원칙**: 결정 권한은 사람. 챗봇은 설명과 시뮬레이션만.

### 5.4 기술 요구사항

```typescript
// 챗봇-콘솔 연결 인터페이스
interface AiChatContextInjection {
  mode: 'CONTEXTUAL';        // 일반 대화가 아닌 컨텍스트 주입 모드
  injectedContext: {
    insightId: string;       // 인사이트 카드 ID
    insightType: string;     // DELAY | RISK | ...
    insightTitle: string;    // 카드 제목
    projectId: string;
    asOf: string;            // 기준 시점
    evidenceRef: string[];   // 관련 엔티티 ID 목록
    summary: string;         // 인사이트 요약
  };
}
```

**중요**: 챗봇은 Insight ID를 기준으로만 대답. 새 판단 생성 불가, 기존 판단 해석만 가능.

---

## 6. Capability 기반 "AI 행동 버튼" 설계

### 6.1 행동 버튼 노출 조건

```typescript
function shouldRenderActionButton(
  action: AiRecommendedAction,
  insight: AiInsight,
  userCapabilities: string[]
): boolean {
  return (
    userCapabilities.includes(action.requiredCapability) &&
    getSeverityLevel(insight.severity) >= MINIMUM_SEVERITY_FOR_ACTION[action.actionId]
  );
}

// 심각도 임계값
const MINIMUM_SEVERITY_FOR_ACTION: Record<string, string> = {
  'create-issue': 'LOW',        // 이슈 생성은 낮은 심각도부터
  'create-risk': 'MEDIUM',      // 리스크 등록은 중간 이상
  'escalate-pmo': 'HIGH',       // PMO 에스컬레이션은 높음 이상
  'reassign-task': 'MEDIUM',    // 작업 재할당은 중간 이상
  'create-meeting-agenda': 'MEDIUM',
  'run-governance': 'HIGH',
  'create-deliverable': 'LOW',
  'update-progress': 'INFO',
};
```

### 6.2 대표 Action 유형 및 매핑

| Action ID | 라벨 | 연결 화면 | 필요 Capability | 최소 심각도 |
|-----------|------|----------|----------------|-----------|
| `create-issue` | 이슈로 등록 | `/issues?action=new` | `manage_issues` | LOW |
| `create-risk` | 리스크 승격 | `/decision-risk?tab=risk&action=new` | `manage_risks` | MEDIUM |
| `escalate-pmo` | PMO 에스컬레이션 | `/pmo-console?action=escalation` | `manage_pmo` | HIGH |
| `create-meeting-agenda` | 회의 안건 생성 | `/meetings?action=new` | `manage_meetings` | MEDIUM |
| `reassign-task` | 작업 재할당 | `/kanban?action=bulk-assign` | `manage_tasks` | MEDIUM |
| `run-governance` | 거버넌스 점검 | `/role-permission?tab=governance` | `manage_governance` | HIGH |
| `create-deliverable` | 산출물 등록 | `/deliverables?action=new` | `manage_deliverables` | LOW |
| `update-progress` | 진행률 갱신 | `/my-work` | `update_own_tasks` | INFO |

### 6.3 행동 버튼 동작 흐름 — "AI에서 왔다" 컨텍스트 전달

```
사용자가 [리스크 등록] 버튼 클릭
    │
    ▼
Capability 검증 (프론트엔드 CapabilityGuard)
    │
    ├── 권한 없음 → 버튼 비활성 + 툴팁 "권한이 필요합니다"
    │
    └── 권한 있음 → 라우트 이동
            │
            ▼
        /decision-risk?tab=risk&action=new&sourceInsight=insight-delay-01
            │
            ▼
        대상 화면의 Route Guard → Capability 재검증 (이중 보호)
            │
            ▼
        리스크 등록 폼에 사전 데이터 주입:
        - 제목: "[AI 감지] 결제 모듈 작업 지연"
        - 설명: 인사이트 description 자동 입력
        - 관련 엔티티: evidence.entities 자동 연결
        - "[AI 콘솔에서 생성됨]" 배너 표시 (sourceInsight 쿼리 파라미터 존재 시)
            │
            ▼
        사용자가 저장 → Change History에 "AI 추천 기반 생성" 출처 기록
        사용자가 취소 → Decision Trace에 CANCELLED 기록
```

> **v1.1 추가**: `sourceInsight` 쿼리 파라미터가 있으면 대상 화면에서 "AI 콘솔에서 추천된 항목입니다" 배너를 표시하고, Change History에 출처를 기록한다.

### 6.4 핵심 설계 원칙

| 원칙 | 설명 |
|------|------|
| **AI는 추천만** | 직접 DB 변경 절대 불가 |
| **기존 흐름 재사용** | 신규 CRUD 화면 만들지 않음. 기존 PMS 화면으로 이동 |
| **감사 로그 유지** | 모든 변경은 기존 Change History에 기록 + "AI 추천 기반" 출처 표시 |
| **Capability 이중 보호** | 프론트 CapabilityGuard + 대상 화면 Route Guard 모두 적용 |

---

## 7. 컴포넌트 트리

### 7.1 React 컴포넌트 구조

```
<AiAssistantPage>
  ├── <AiContextHeader />           ← [A] 프로젝트·역할·기준시점·완결성
  │     ├── <CompletenessIndicator />  ← v1.1: FULL/PARTIAL/UNKNOWN 배지
  │     └── <ScopeSelector />          ← v1.1: scope 변경 드롭다운
  ├── <AiBriefingPanel />           ← [B] 자동 생성 요약
  │     ├── <HealthStatusBadge />
  │     ├── <SignalTagList />
  │     ├── <CompletenessWarning />    ← v1.1: PARTIAL 경고 배너
  │     └── <BriefingSummary />
  ├── <InsightCardList />           ← [C] 인사이트 카드 목록
  │     └── <InsightCard />         ← 개별 카드 (반복)
  │           ├── <SeverityBadge />
  │           ├── <InsightTypeBadge />
  │           ├── <ConfidenceIndicator />
  │           ├── <EvidenceSummary />
  │           ├── <ActionButtonGroup /> ← Capability 검증된 버튼
  │           └── <AskChatButton />    ← 챗봇 연결 버튼
  ├── <RecommendedActionPanel />    ← [D] 추천 행동 허브
  │     └── <ActionCard />
  │           ├── <CapabilityGuard />
  │           └── <DeepLinkButton />
  └── <ExplainabilityDrawer />      ← [E] 설명 책임 패널 (접힘/펼침)
        ├── <CompletenessDetail />     ← v1.1: 완결성 상세 + missingSignals
        ├── <DataSourceList />
        ├── <WarningList />
        ├── <GenerationMethodBadge />
        └── <ChangeHistoryLinks />     ← Lineage 딥링크
```

### 7.2 주요 파일 목록

| 파일 경로 | 설명 |
|-----------|------|
| `src/app/components/AiAssistantPage.tsx` | 메인 페이지 컴포넌트 (레이아웃 조립) |
| `src/app/components/ai/AiContextHeader.tsx` | 판단 맥락 헤더 + 완결성 배지 + scope 변경 |
| `src/app/components/ai/AiBriefingPanel.tsx` | 자동 요약 패널 + 완결성 경고 |
| `src/app/components/ai/InsightCardList.tsx` | 인사이트 카드 목록 |
| `src/app/components/ai/InsightCard.tsx` | 개별 인사이트 카드 |
| `src/app/components/ai/RecommendedActionPanel.tsx` | 추천 행동 패널 |
| `src/app/components/ai/ExplainabilityDrawer.tsx` | 설명 책임 패널 + Lineage 딥링크 |
| `src/app/components/ai/ActionButtonGroup.tsx` | Capability 연동 액션 버튼 (이중 보호) |
| `src/app/components/ai/AskChatButton.tsx` | 챗봇 컨텍스트 주입 버튼 |
| `src/hooks/api/useAiBriefing.ts` | AI 브리핑 API TanStack Query 훅 |
| `src/types/aiBriefing.ts` | 스키마 타입 정의 |

### 7.3 API 연동 훅

```typescript
// src/hooks/api/useAiBriefing.ts

export const aiBriefingKeys = {
  all: ['ai-briefing'] as const,
  // v1.1: scope를 query key에 포함하여 scope 변경 시 자동 재조회
  briefing: (projectId: string, role: string, scope?: string) =>
    [...aiBriefingKeys.all, projectId, role, scope ?? 'default'] as const,
};

/** 프로젝트 AI 브리핑 조회 */
export function useAiBriefing(
  projectId: string | undefined,
  role: string,
  scope?: BriefingScope
) {
  return useQuery<AiBriefingResponse>({
    queryKey: aiBriefingKeys.briefing(projectId || '', role, scope),
    queryFn: () => apiService.getAiBriefing(projectId!, role, scope),
    enabled: !!projectId,
    staleTime: 5 * 60 * 1000,  // 5분 캐시
    refetchOnWindowFocus: false,
  });
}

/** 수동 브리핑 재생성 — Rule-only 즉시 반환 */
export function useRefreshBriefing() {
  const queryClient = useQueryClient();
  return useMutation({
    mutationFn: ({ projectId, role, scope }: {
      projectId: string; role: string; scope?: BriefingScope;
    }) => apiService.refreshAiBriefing(projectId, role, scope),
    onSuccess: (_, { projectId, role, scope }) => {
      queryClient.invalidateQueries({
        queryKey: aiBriefingKeys.briefing(projectId, role, scope),
      });
    },
  });
}
```

---

## 8. 백엔드 API 설계

### 8.1 API 엔드포인트

| Method | Path | 설명 |
|--------|------|------|
| `GET` | `/api/v2/projects/{projectId}/ai/briefing?role={role}&scope={scope}` | AI 브리핑 조회 |
| `POST` | `/api/v2/projects/{projectId}/ai/briefing/refresh` | 브리핑 수동 재생성 |
| `GET` | `/api/v2/projects/{projectId}/ai/insights` | 인사이트 목록 조회 |
| `GET` | `/api/v2/projects/{projectId}/ai/insights/{insightId}` | 인사이트 상세 |
| `GET` | `/api/v2/projects/{projectId}/ai/actions` | 추천 행동 목록 |
| `GET` | `/api/v2/projects/{projectId}/ai/trace-log?from={date}&to={date}` | Decision Trace 로그 조회 |
| `POST` | `/api/v2/projects/{projectId}/ai/trace-log` | Decision Trace 이벤트 기록 |

### 8.2 브리핑 생성 흐름

```
프론트엔드 GET /ai/briefing?role=PM&scope=current_sprint
    │
    ▼
백엔드 (Spring WebFlux)
    │
    ├── Redis 캐시 확인
    │     ├── 캐시 히트 → 즉시 반환 (< 200ms)
    │     └── 캐시 미스 → 생성 흐름 진입
    │
    ▼
asOf 시점 고정 (이 시각 이후의 모든 쿼리는 이 시점 기준)
    │
    ▼
Aggregation Service (asOf 기준 스냅샷 쿼리)
    │
    ├── PostgreSQL: 태스크 현황, 스프린트 상태, 이슈 통계
    ├── Neo4j: 종속성 그래프, 병목 분석
    ├── Redis: 최근 활동 로그
    │
    ▼
데이터 완결성 검증 (v1.1)
    │
    ├── 모든 소스 정상 → completeness: FULL
    ├── 일부 소스 누락/지연 → completeness: PARTIAL + missingSignals 기록
    └── 소스 상태 알 수 없음 → completeness: UNKNOWN
    │
    ▼
Insight 생성 엔진
    │
    ├── Rule-based: 임계값 기반 탐지 (지연, SoD, 만료)
    ├── Model-based: LLM 패턴 분석 (이상 징후, 트렌드)
    └── Hybrid: Rule 결과를 LLM이 자연어로 정리
    │
    ▼
역할별 관점 필터링
    │
    ├── PM → 실행/병목/스프린트 중심
    ├── PMO → 통제/편차/정책 중심
    └── DEV → 내작업/블로커/코드 중심
    │
    ▼
AiBriefingResponse 조립 + Redis 캐싱
    │
    ▼
프론트엔드 반환
```

### 8.3 Redis 캐시 키 설계

```
ai:briefing:{projectId}:{role}:{scope}
```

| 구성 요소 | 예시 | 설명 |
|-----------|------|------|
| `projectId` | `proj-001` | 프로젝트 식별자 |
| `role` | `PM` | 역할 (관점 필터링이 다르므로 분리) |
| `scope` | `current_sprint` | 분석 범위 |

- **TTL**: 5분 (기본)
- **공유 정책**: 동일 projectId + role + scope면 프로젝트 내 10명이 동시 조회해도 캐시 1건 공유
- **무효화**: Refresh API 호출 시 해당 키만 삭제

### 8.4 Refresh 버튼 동작 정의

| 단계 | 동작 | 예상 시간 |
|------|------|----------|
| 1. 캐시 무효화 | Redis 키 삭제 | < 10ms |
| 2. Rule-only 즉시 생성 | SQL 집계 + Rule Engine | < 3초 |
| 3. 즉시 반환 | Rule 기반 브리핑을 프론트에 전달 | 즉시 |
| 4. (백그라운드) LLM 보강 | Rule 결과를 LLM으로 자연어 정리 | 3~8초 |
| 5. (백그라운드 완료 시) 캐시 갱신 | LLM 보강 결과로 캐시 교체 | — |
| 6. 프론트 자동 갱신 | `staleTime` 만료 시 또는 SSE push로 갱신 | — |

> **핵심**: Refresh 버튼은 항상 3초 내에 Rule-only 결과를 반환한다. LLM 보강은 백그라운드에서 진행되어 완료 시 자동 갱신된다. 사용자가 8초를 기다리는 일은 없다.

### 8.5 데이터 소스 혼합 규칙

| 데이터 유형 | 1차 소스 | 2차 소스 | 설명 |
|------------|---------|---------|------|
| 숫자/집계 (태스크 수, 진행률, 이슈 통계) | **PostgreSQL** | — | R2DBC Reactive 쿼리 |
| 관계/의존/영향 (그래프 분석) | **Neo4j** | — | Cypher 쿼리 |
| 최근 활동 로그 (이벤트 스트림) | **Redis** | — | Sorted Set / Stream |
| 자연어 요약/패턴 분석 | **LLM** | — | Rule 결과 + Metrics 입력 |

> LLM은 "판단 생성"이 아니라 "요약/정리" 역할로 제한 (초기). Rule이 근거를 만들고, LLM은 읽기 쉽게 정리한다.

### 8.6 LLM 서비스 연동

기존 `llm-service` (Flask + LangGraph)에 새 엔드포인트 추가:

```
POST /api/ai/briefing/generate
```

**요청:**
```json
{
  "projectId": "proj-001",
  "role": "PM",
  "scope": "current_sprint",
  "asOf": "2026-02-09T10:30:00+09:00",
  "rawMetrics": {
    "overdue_tasks": 3,
    "sprint_burndown_gap": 15,
    "open_issues": 7,
    "test_coverage": 78.5
  },
  "ruleFindings": [
    { "type": "DELAY", "entities": ["task-101", "task-104"] }
  ],
  "completeness": "PARTIAL",
  "missingSignals": ["commits_last_3d"]
}
```

**응답:**
```json
{
  "headline": "이번 스프린트는 일정 지연 위험이 있습니다",
  "body": "3개 태스크가 예정일을 초과했으며...",
  "insights": [...],
  "generationMethod": "HYBRID"
}
```

---

## 9. Preset별 UI 정책

### 9.1 역할별 Preset 분기

| Preset | 대상 역할 | 브리핑 초점 | 인사이트 필터 | 액션 우선순위 |
|--------|---------|-----------|-------------|-------------|
| `EXEC_SUMMARY` | Sponsor | 전체 진행률, 예산, 마일스톤 | RISK, PROGRESS | 에스컬레이션, 보고서 |
| `PMO_CONTROL` | PMO_HEAD | 프로젝트 간 편차, 정책 | POLICY_GAP, BOTTLENECK | 거버넌스 점검, 감사 |
| `PM_WORK` | PM | 실행 지연, 담당자, 스프린트 | DELAY, BOTTLENECK, QUALITY | 이슈 등록, 재할당 |
| `DEV_EXECUTION` | DEV, QA | 내 작업, 블로커, 테스트 | DELAY (내 담당만), QUALITY | 진행률 갱신 |

### 9.2 UI 밀도 설정

| Preset | 밀도 | 카드 표시 개수 | 설명 상세도 |
|--------|------|--------------|-----------|
| `EXEC_SUMMARY` | compact | 최대 3개 | 제목 + 1줄 요약 |
| `PMO_CONTROL` | standard | 최대 7개 | 제목 + 설명 + 근거 요약 |
| `PM_WORK` | detailed | 전체 | 제목 + 설명 + 근거 + 메트릭 |
| `DEV_EXECUTION` | standard | 내 담당만 | 제목 + 설명 + 다음 행동 |

---

## 10. 인사이트 생성 규칙

### 10.1 Rule-based 탐지 (즉시 실행)

| 규칙 ID | 유형 | 조건 | 심각도 |
|---------|------|------|--------|
| `R-DELAY-01` | DELAY | `task.due_date < NOW() AND task.status != 'DONE'` | 태스크 수에 따라 MEDIUM~CRITICAL |
| `R-DELAY-02` | DELAY | `milestone.target_date - NOW() < 7 days AND progress < 80%` | HIGH |
| `R-BOTTLE-01` | BOTTLENECK | `COUNT(active_tasks WHERE assignee = X) > 10` | MEDIUM |
| `R-BOTTLE-02` | BOTTLENECK | `COUNT(DISTINCT assignee WHERE part = X) < 2` | HIGH (단일 장애점) |
| `R-QUALITY-01` | QUALITY | `test_pass_rate < 80%` | HIGH |
| `R-QUALITY-02` | QUALITY | `test_coverage delta < -5% (7일간)` | MEDIUM |
| `R-POLICY-01` | POLICY_GAP | `governance.findings WHERE severity = 'HIGH'` | HIGH |
| `R-RESOURCE-01` | RESOURCE | `part_member_count = 0 WHERE part.status = 'ACTIVE'` | MEDIUM |

### 10.2 Model-based 분석 (LLM 활용)

| 분석 유형 | 입력 데이터 | 출력 |
|-----------|-----------|------|
| 트렌드 분석 | 최근 14일 번다운 차트 데이터 | 완료 가능성 예측 |
| 병목 패턴 | 태스크 상태 전이 로그 | 반복되는 블로킹 패턴 |
| 리스크 상관관계 | 오픈 이슈 + 지연 태스크 | 연쇄 리스크 식별 |
| 자연어 요약 | Rule 탐지 결과 + 메트릭 | 사람이 읽을 수 있는 브리핑 |

### 10.3 Hybrid 방식 (기본 운영 모드)

```
1. asOf 시점 고정
2. Rule Engine → 구조적 탐지 결과 생성 (asOf 기준 쿼리)
3. 데이터 완결성 검증 → completeness + missingSignals 판정
4. 탐지 결과 + Raw Metrics + completeness → LLM 입력
5. LLM → 자연어 요약 + 추가 패턴 분석
6. 최종 AiBriefingResponse 조립 (모든 evidence.asOf = context.asOf 확인)
```

> Rule이 먼저 실행되어 기반을 잡고, LLM이 그 위에서 해석과 요약을 추가하는 구조

---

## 11. 감사 대응용 AI Decision Trace 로그

### 11.1 목적

AI가 생성한 인사이트와 추천 행동에 대해 **"언제, 무슨 근거로, 누구에게 무엇을 추천했고, 사용자가 어떻게 반응했는가"**를 추적 가능하게 기록한다.

### 11.2 로그 스키마 (v1.1 보강)

```sql
CREATE TABLE IF NOT EXISTS ai.decision_trace_log (
  id            VARCHAR(36) PRIMARY KEY,
  project_id    VARCHAR(36) NOT NULL,
  user_id       VARCHAR(36) NOT NULL,
  user_role     VARCHAR(50) NOT NULL,

  -- 이벤트 유형
  event_type    VARCHAR(30) NOT NULL,  -- BRIEFING_GENERATED | INSIGHT_VIEWED |
                                       -- ACTION_CLICKED | ACTION_COMPLETED |
                                       -- ACTION_CANCELLED | CHAT_CONTEXT_INJECTED

  -- AI 판단 내용
  briefing_id   VARCHAR(36) NOT NULL,
  insight_id    VARCHAR(36),
  insight_type  VARCHAR(50),
  severity      VARCHAR(20),
  confidence    DECIMAL(3,2),

  -- 추천 행동 (v1.1: 행동 시도→실행→취소 전체 라이프사이클 추적)
  action_id     VARCHAR(50),
  action_result VARCHAR(20),           -- CLICKED | COMPLETED | CANCELLED | FAILED

  -- 메타데이터
  generation_method VARCHAR(20),       -- RULE_BASED | MODEL_BASED | HYBRID
  completeness  VARCHAR(10),           -- FULL | PARTIAL | UNKNOWN (v1.1)
  data_sources  JSONB,                 -- 사용된 데이터 소스 상세
  evidence_json JSONB,                 -- 판단 근거 스냅샷
  as_of         TIMESTAMPTZ,           -- 브리핑 기준 시점 (v1.1)

  -- 시점
  generated_at  TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  action_clicked_at  TIMESTAMPTZ,      -- v1.1: 콘솔에서 버튼 클릭 시각
  action_completed_at TIMESTAMPTZ,     -- v1.1: 대상 화면에서 저장 완료 시각

  CONSTRAINT fk_project FOREIGN KEY (project_id) REFERENCES project.projects(id)
);

CREATE INDEX idx_trace_project ON ai.decision_trace_log(project_id, generated_at);
CREATE INDEX idx_trace_user ON ai.decision_trace_log(user_id, generated_at);
CREATE INDEX idx_trace_event ON ai.decision_trace_log(event_type, generated_at);
CREATE INDEX idx_trace_action ON ai.decision_trace_log(action_id, action_result) WHERE action_id IS NOT NULL;
```

### 11.3 이벤트 유형별 기록 시점

| 이벤트 | event_type | 기록 내용 |
|--------|-----------|---------|
| 브리핑 생성 | `BRIEFING_GENERATED` | briefing_id, 전체 인사이트 목록, 생성 방식, completeness, as_of |
| 인사이트 열람 | `INSIGHT_VIEWED` | 사용자가 어떤 인사이트를 열어봤는지 |
| 행동 버튼 클릭 | `ACTION_CLICKED` | action_id, action_result='CLICKED', action_clicked_at |
| 대상 화면 저장 성공 | `ACTION_COMPLETED` | action_result='COMPLETED', action_completed_at |
| 대상 화면 취소 | `ACTION_CANCELLED` | action_result='CANCELLED' |
| 대상 화면 저장 실패 | `ACTION_FAILED` | action_result='FAILED' + 에러 상세 |
| 챗봇 컨텍스트 전환 | `CHAT_CONTEXT_INJECTED` | insight_id 기반 챗봇 질의 시작 |

> **v1.1 핵심 개선**: `action_taken` boolean 대신 전체 라이프사이클을 추적한다. 이를 통해 **"AI가 추천했고 사람이 실행했는가?"**가 정확히 증명된다.

### 11.4 감사 보고서 연동

```
GET /api/v2/projects/{projectId}/ai/trace-log?from={date}&to={date}&eventType={type}
```

이 API는 감사증빙(`/audit-evidence`) 화면에서 다음 보고서로 Export 가능하도록 설계한다:

| 보고서 유형 | 내용 |
|------------|------|
| **AI 추천 이력** | 기간 내 전체 인사이트 + 추천 행동 목록 |
| **AI 추천 실행률** | 추천 중 실제 COMPLETED 비율 |
| **AI 데이터 품질** | completeness별 분포, 누락 신호 빈도 |
| **사용자 반응 분석** | CLICKED→COMPLETED/CANCELLED/FAILED 전환율 |

---

## 12. PMS v2.0 시스템 연동 — 딥링크·Lineage·감사

### 12.1 Virtual Node 딥링크 — "AI에서 왔다" 컨텍스트

RecommendedAction의 딥링크는 단순 route 이동이 아니라, `sourceInsight` 파라미터를 통해 대상 화면에서 "AI에서 왔다" 컨텍스트를 표시한다:

```typescript
// 딥링크 URL 생성
function buildDeepLink(action: AiRecommendedAction, insight: AiInsight): string {
  const url = new URL(action.targetRoute, window.location.origin);
  url.searchParams.set('sourceInsight', insight.id);
  url.searchParams.set('sourceAsOf', briefing.context.asOf);
  return url.pathname + url.search;
}
```

**대상 화면 동작:**
1. `sourceInsight` 쿼리 파라미터 감지
2. "AI 콘솔에서 추천된 항목입니다" 배너 표시
3. 인사이트 데이터로 폼 프리필 (제목, 설명, 관련 엔티티)
4. 저장 시 Change History에 `source: 'AI_INSIGHT'` + `insightId` 기록

### 12.2 Lineage & History 연결

ExplainabilityDrawer의 `changeHistoryLinks`는 Lineage 화면으로 직접 연결된다:

```typescript
// Lineage 딥링크 생성
changeHistoryLinks: [
  {
    label: "task-101 변경 이력",
    route: "/lineage/Task/task-101"    // /lineage/:entityType/:entityId
  },
  {
    label: "task-104 변경 이력",
    route: "/lineage/Task/task-104"
  }
]
```

> AI가 근거를 댔으면 인간이 추적 가능해야 한다. Lineage 딥링크는 이 원칙의 구현체이다.

### 12.3 PMO/감사 화면 연동

Decision Trace Log는 다음 화면에서 소비된다:

| 소비 화면 | 용도 | API |
|-----------|------|-----|
| `/audit-evidence` | "AI 의사결정 추적 보고서" Export | `GET /ai/trace-log?from=&to=` |
| `/pmo-console` | AI 추천 실행률 대시보드 | `GET /ai/trace-log?eventType=ACTION_COMPLETED` |
| `/reports` | AI 활용도 리포트 위젯 | 집계 API (별도 설계) |

---

## 13. 테스트 전략

### 13.1 계약 테스트 (Contract)

| 테스트 | 대상 | 검증 내용 |
|--------|------|----------|
| `AiBriefingResponse` 스키마 | 백엔드 → 프론트 | JSON 필드/타입 일치, 누락 시 즉시 실패 |
| `AiInsight.evidence.asOf` 일관성 | 백엔드 | 모든 evidence.asOf === context.asOf 검증 |
| `completeness` + `missingSignals` 정합 | 백엔드 | PARTIAL이면 missingSignals 비어있지 않음 |

### 13.2 권한 테스트 (Access)

| 테스트 | 조건 | 예상 결과 |
|--------|------|----------|
| 화면 접근 | `view_ai_assistant` 없는 유저 | `/ai-assistant` 403 또는 리다이렉트 |
| 버튼 노출 | PM (manage_issues O) | "이슈로 등록" 버튼 보임 |
| 버튼 숨김 | Developer (manage_pmo X) | "PMO 에스컬레이션" 버튼 미노출 |
| 이중 보호 | Capability 있지만 대상 Route Guard 실패 | 딥링크 대상 화면에서 403 |

### 13.3 결정 추적 테스트 (Trace)

| 테스트 | 트리거 | 검증 |
|--------|--------|------|
| 브리핑 생성 | GET /ai/briefing | trace 1건 `BRIEFING_GENERATED` 기록 확인 |
| 인사이트 열람 | 카드 클릭 | trace 1건 `INSIGHT_VIEWED` 기록 확인 |
| 챗봇 연결 | "질문하기" 클릭 | trace 1건 `CHAT_CONTEXT_INJECTED` 기록 확인 |
| 행동 클릭 | 액션 버튼 클릭 | trace `ACTION_CLICKED` + action_clicked_at 확인 |
| 행동 완료 | 대상 화면 저장 | trace `ACTION_COMPLETED` + action_completed_at 확인 |
| 행동 취소 | 대상 화면 취소 | trace `ACTION_CANCELLED` 확인 |

### 13.4 스냅샷 일관성 테스트

| 테스트 | 검증 |
|--------|------|
| `evidence.asOf` 동일성 | 브리핑 내 모든 insight의 evidence.asOf === context.asOf |
| 캐시 무효화 후 asOf 변경 | Refresh 후 새로운 asOf가 생성되고, 이전 asOf와 다름 |
| 데이터 소스 시점 | dataSources.lastSyncAt이 asOf보다 이전 또는 동일 |

---

## 14. 구현 우선순위

### Phase 1 — 기본 프레임 (MVP)

| 순서 | 항목 | 설명 | 티켓 ID |
|------|------|------|---------|
| 1 | `AiAssistantPage.tsx` | PlaceholderPage 대체, 레이아웃 쉘 구성, Skeleton UI | FE-AI-01 |
| 2 | `AiContextHeader` | 프로젝트·역할·시점·완결성 배지·scope 드롭다운 | FE-AI-02 |
| 3 | `useAiBriefing` + `aiBriefing.ts` 타입 | TanStack Query 훅 + 타입 정의 분리 | FE-AI-03 |
| 4 | `AiBriefingPanel` | Rule-based 브리핑 (LLM 없이 메트릭 기반) + 완결성 경고 | FE-AI-04 |
| 5 | `InsightCardList` + `InsightCard` | 정적 규칙 기반 인사이트 카드 + confidence 약화 스타일 | FE-AI-05 |
| 6 | 백엔드 Aggregation API | asOf 고정 + Rule Engine + completeness 검증 → 응답 | BE-AI-01 |

### Phase 2 — 행동 연결

| 순서 | 항목 | 설명 | 티켓 ID |
|------|------|------|---------|
| 7 | `RecommendedActionPanel` | Capability 기반 행동 버튼 + 이중 보호 | FE-AI-06 |
| 8 | `ActionButtonGroup` | 딥링크 + sourceInsight 전달 + "AI에서 왔다" 배너 | FE-AI-07 |
| 9 | 챗봇 컨텍스트 연결 | `AskChatButton` → `AIAssistant.tsx` 연동 | FE-AI-08 |

### Phase 3 — 설명 책임 + LLM 고도화

| 순서 | 항목 | 설명 | 티켓 ID |
|------|------|------|---------|
| 10 | `ExplainabilityDrawer` | 데이터 소스·완결성·신뢰도·경고 + Lineage 딥링크 | FE-AI-09 |
| 11 | LLM 통합 | Hybrid 방식 (Rule-first 즉시반환 + LLM 백그라운드 보강) | BE-AI-02 |
| 12 | Decision Trace Log | 테이블 + API + 프론트 이벤트 전송 | BE-AI-03 |

### Phase 4 — Preset 고도화 + 감사 연동

| 순서 | 항목 | 설명 | 티켓 ID |
|------|------|------|---------|
| 13 | 역할별 Preset 분기 | PM/PMO/DEV/Sponsor 관점 전환 + resolvePresetByRole | FE-AI-10 |
| 14 | 감사 보고서 Export | 감사증빙 화면에서 "AI 의사결정 추적 보고서" Export | FE-AI-11 |
| 15 | PMO 콘솔 연동 | AI 추천 실행률 대시보드 위젯 | FE-AI-12 |

---

## 15. 비기능 요구사항

| 항목 | 기준 |
|------|------|
| **브리핑 생성 시간** | 캐시 히트 < 200ms, 캐시 미스 Rule-only < 3초, Hybrid 백그라운드 < 8초 |
| **Refresh 체감 시간** | 항상 3초 내 Rule-only 결과 반환. LLM 보강은 백그라운드 |
| **캐시 TTL** | Redis 5분, 수동 갱신 가능 |
| **캐시 키** | `ai:briefing:{projectId}:{role}:{scope}` |
| **동시 사용자** | 프로젝트당 10명 동시 조회 시에도 캐시 공유 |
| **데이터 정합성** | asOf 기준 시점 명시, 모든 evidence.asOf === context.asOf |
| **데이터 완결성** | completeness 항상 표기, PARTIAL 시 missingSignals 명시 |
| **접근성** | WCAG 2.1 AA 준수, 심각도 배지는 색상 + 아이콘 + 텍스트 삼중 표현 |
| **반응형** | 1280px 이상 최적화, 768px 이상 지원 |

---

## 16. 에픽/스프린트 구성 + 공통 기준

### 16.1 에픽 구성

| Epic | 이름 | 목표 | 선행 조건 |
|------|------|------|----------|
| **A1** | AI Assistant Console MVP (Rule-first) | LLM 없이도 항상 뜨는 의사결정 콘솔 — Push형 브리핑 + 인사이트 + 액션 딥링크 | 없음 |
| **A2** | Chatbot Context Bridge | Insight → 오른쪽 챗봇(Global Copilot)으로 컨텍스트 주입 및 Trace 기록 | A1 완료 |
| **A3** | Explainability & Trace (감사 대응) | asOf/데이터소스/완결성/경고 + AI Decision Trace Log 저장/조회 | A1 완료 |
| **A4** | Hybrid (Rule + LLM 요약) 고도화 | Rule 결과를 기반으로 LLM이 요약/표현만 강화 (판단은 Rule이 앵커) | A1 + A3 완료 |

**에픽 → 스프린트 매핑 (권장):**

```
Sprint 1 (2주): A1 전체 (FE-101~106, BE-201~204)
Sprint 2 (2주): A2 (FE-107) + A3 (FE-108, BE-301, FE-302)
Sprint 3 (2주): A4 (LLM-401) + 안정화/E2E 테스트
```

### 16.2 공통 기준 — 개발 전 합의 필수

#### B1) 스냅샷 일관성 원칙 (강제)

하나의 브리핑 응답은 **단일 `asOf`**를 가진다. 브리핑/인사이트/evidence는 모두 동일 `asOf` 스냅샷 기준으로 계산된다.

```
[강제] context.asOf === insight[*].evidence.asOf
[강제] dataSources[*].lastSyncAt <= context.asOf
[금지] 브리핑 10:30 기준 + evidence 10:32 데이터
```

#### B2) 완결성(completeness) 표기 (강제)

```
explainability.completeness = FULL | PARTIAL | UNKNOWN
IF completeness === PARTIAL THEN missingSignals.length > 0
IF completeness === PARTIAL THEN warnings.length > 0
```

#### B3) 권한 원칙 (강제)

```
진입:  view_ai_assistant → 라우트 가드 + 메뉴 노출
버튼:  action.requiredCapability → CapabilityGate 렌더링 제어
이동:  대상 화면 Route Guard → 2차 보호 (이중 보호)
```

> 이 세 원칙은 모든 티켓의 AC에 암묵적으로 포함된다. 코드 리뷰 시 위반하면 reject.

---

## 17. 상세 구현 티켓 (AC + 테스트)

> 아래는 "한 장씩 완성되는 순서"로 정렬되어 있다. 그대로 Sprint Plan에 넣으면 된다.

### 17.1 프론트엔드 — Epic A1 (MVP Console)

---

#### FE-101 — `/ai-assistant` 페이지 쉘 교체 (Placeholder 제거)

| 항목 | 내용 |
|------|------|
| **Epic** | A1 |
| **설명** | 기존 `PlaceholderPage`를 `AiAssistantPage` 레이아웃으로 교체. Skeleton/EmptyState/ErrorState 포함 |
| **완료물** | `AiAssistantPage.tsx`, 기본 영역 5개(A~E) 레이아웃 뼈대 + 로딩/에러 상태 |

**수용 기준 (AC):**

- [ ] `/ai-assistant` 진입 시 Placeholder가 아닌 콘솔 레이아웃이 렌더링된다
- [ ] API 응답 전에는 Skeleton이 표시된다
- [ ] API 에러 시 ErrorState (재시도 버튼 포함)가 표시된다
- [ ] `view_ai_assistant` 없는 계정은 403 처리된다 (기존 ProtectedRoute 정책 준수)

**테스트:**

| 유형 | 케이스 | 예상 결과 |
|------|--------|----------|
| E2E | 권한 없는 유저 `/ai-assistant` 접근 | 403 화면 또는 리다이렉트 |
| UI | 로딩 상태 | Skeleton 노출 스냅샷 일치 |
| UI | 네트워크 실패 | ErrorState 노출 + 재시도 동작 |

---

#### FE-102 — `AiBriefingResponse` 타입/스키마 고정 + API 훅 생성

| 항목 | 내용 |
|------|------|
| **Epic** | A1 |
| **설명** | 문서 §4의 TypeScript 인터페이스를 실제 타입 파일로 고정하고 TanStack Query 훅 작성 |
| **완료물** | `src/types/aiBriefing.ts`, `src/hooks/api/useAiBriefing.ts` |

**수용 기준 (AC):**

- [ ] `AiBriefingResponse` 타입이 단일 소스(`src/types/aiBriefing.ts`)로 정의된다
- [ ] `useAiBriefing(projectId, role, scope)` 훅이 동작한다
- [ ] `staleTime=5분`, `refetchOnWindowFocus=false` 적용된다
- [ ] `useRefreshBriefing()` mutation이 해당 queryKey를 invalidate한다

**테스트:**

| 유형 | 케이스 | 예상 결과 |
|------|--------|----------|
| 단위 | 타입 유효성 | 빌드 통과 (tsc --noEmit) |
| 단위 | queryKey 구성 | `['ai-briefing', projectId, role, scope]` 형태 |
| 통합 | GET 성공 | 데이터 바인딩 확인 |
| 통합 | POST refresh | invalidate 후 재조회 확인 |

---

#### FE-103 — `AiContextHeader` 구현 (프로젝트/역할/asOf/scope/갱신)

| 항목 | 내용 |
|------|------|
| **Epic** | A1 |
| **설명** | 브리핑 맥락을 상단에서 강제 표기하고 scope 선택 + refresh 제공 |
| **UX 결정** | scope는 Header에서 선택 (기본 `current_sprint`), 변경 시 `?scope=` 쿼리스트링 반영 |

**수용 기준 (AC):**

- [ ] 프로젝트명/역할/asOf/scope가 항상 표시된다
- [ ] Refresh 클릭 시 브리핑이 재조회된다 (로딩 표시 포함)
- [ ] scope 변경 시 브리핑이 해당 범위로 재조회된다
- [ ] asOf는 로컬 포맷(KST)으로 표기된다 (내부값은 ISO 유지)
- [ ] `completeness` 배지가 표시된다 (FULL=초록 / PARTIAL=노랑 / UNKNOWN=회색)

**테스트:**

| 유형 | 케이스 | 예상 결과 |
|------|--------|----------|
| UI | scope 변경 | queryKey 변경 → 재조회 |
| UI | refresh 클릭 | loading → 최신 응답 반영 |
| 접근성 | 버튼/드롭다운 | 키보드 포커스 가능 |

---

#### FE-104 — `AiBriefingPanel` 구현 (헤드라인/신호/헬스/신뢰도/본문)

| 항목 | 내용 |
|------|------|
| **Epic** | A1 |
| **설명** | Push형 요약 패널. 입력창 없음. 화면 진입 시 자동 표시 |

**수용 기준 (AC):**

- [ ] headline/signals/healthStatus/confidence/body가 표시된다
- [ ] `confidence < 0.6`이면 "참고용" 스타일로 표시된다
- [ ] `healthStatus`는 아이콘+텍스트로 동시 표현된다 (색상만 금지)
- [ ] body는 최대 5줄, 초과 시 "더보기"로 펼침
- [ ] `completeness=PARTIAL`이면 경고 배너 표시 ("...분석이 불완전합니다")

**테스트:**

| 유형 | 케이스 | 예상 결과 |
|------|--------|----------|
| UI | confidence 0.59 | "참고용" 스타일 적용 |
| UI | confidence 0.60 | 일반 스타일 |
| 접근성 | 배지/아이콘 | `aria-label` 제공 |
| UI | PARTIAL completeness | 경고 배너 표시 + missingSignals 나열 |

---

#### FE-105 — `InsightCardList` / `InsightCard` 구현

| 항목 | 내용 |
|------|------|
| **Epic** | A1 |
| **설명** | 인사이트 카드 목록. 각 카드는 단일 주장 + 근거 요약 + 행동 버튼 + 질문하기 버튼 포함 |

**수용 기준 (AC):**

- [ ] 각 카드에 type/severity/title/description/confidence/evidence 요약이 표시된다
- [ ] evidence는 최소 metrics 1개 또는 entities 1개 포함 시 표시된다
- [ ] `confidence < 0.6`이면 카드에 "참고용" 배지가 붙는다
- [ ] 카드 클릭으로 상세 확장 (근거 상세 or drawer 링크) 동작한다
- [ ] severity 기준 정렬 (CRITICAL → HIGH → MEDIUM → LOW → INFO)

**테스트:**

| 유형 | 케이스 | 예상 결과 |
|------|--------|----------|
| UI | 인사이트 0개 | EmptyState ("현재 범위에 인사이트 없음") 표시 |
| UI | 인사이트 N개 | 스크롤 정상, severity 순 정렬 확인 |
| 단위 | severity 정렬 | CRITICAL > HIGH > MEDIUM > LOW > INFO |
| UI | confidence 0.55 | "참고용" 배지 표시 + 약화 스타일 |

---

#### FE-106 — `RecommendedActionPanel` 구현 (행동 허브 + 우선순위)

| 항목 | 내용 |
|------|------|
| **Epic** | A1 |
| **설명** | 인사이트에서 파생된 행동을 허브 형태로 재정렬/우선순위화. Capability 기반 렌더링 |

**수용 기준 (AC):**

- [ ] `recommendedActions`가 priority 오름차순으로 렌더링된다
- [ ] 각 액션에 label/description/requiredCapability가 표시된다
- [ ] 권한 없는 액션은 비활성 + 툴팁 ("권한이 필요합니다")
- [ ] 클릭 시 `targetRoute`로 이동하며 `sourceInsight` 쿼리스트링 포함
- [ ] 동일 액션이 중복될 경우 `sourceInsightIds`를 합쳐 1개 카드로 병합 (권장)

**테스트:**

| 유형 | 케이스 | 예상 결과 |
|------|--------|----------|
| UI | 권한 없음 | disabled 상태 + 툴팁 |
| UI | 우선순위 | priority 오름차순 정렬 검증 |
| 통합 | 클릭 시 | 라우트 이동 + `?sourceInsight=insight-xxx` 확인 |
| 단위 | 중복 병합 | 동일 actionId → 1개 카드, sourceInsightIds 합침 |

---

### 17.2 프론트엔드 — Epic A2 (Chatbot Bridge)

---

#### FE-107 — `AskChatButton` 구현 (오른쪽 챗봇 컨텍스트 주입)

| 항목 | 내용 |
|------|------|
| **Epic** | A2 |
| **설명** | 카드의 "이 내용에 대해 질문하기" → Global Copilot 열고 `injectedContext` 주입 |

**수용 기준 (AC):**

- [ ] 버튼 클릭 시 오른쪽 챗봇 패널이 열린다
- [ ] 챗봇 시작 시 시스템 메시지로 insight context가 자동 주입된다
- [ ] 주입 컨텍스트에 insightId/projectId/asOf/evidenceRef/summary 포함
- [ ] 챗봇은 "해당 insight 해석/설명" 범위로 유도 메시지를 가진다 (새 판단 생성 불가)

**테스트:**

| 유형 | 케이스 | 예상 결과 |
|------|--------|----------|
| 통합 | 버튼 클릭 | 챗 패널 오픈 확인 |
| 통합 | 컨텍스트 주입 | 챗봇 첫 메시지에 insight context 포함 |
| UI | 패널 이미 열린 상태 | 기존 대화 유지 + context 추가 주입 |

---

### 17.3 프론트엔드 — Epic A3 (Explainability & Trace)

---

#### FE-108 — `ExplainabilityDrawer` 구현 (기본 접힘 + 책임 패널)

| 항목 | 내용 |
|------|------|
| **Epic** | A3 |
| **설명** | 데이터 소스/완결성/경고/생성방식/ChangeHistory 링크 표시. 기본 접힘 |

**수용 기준 (AC):**

- [ ] 기본 접힘 상태이며 사용자 요청으로 펼쳐진다
- [ ] `dataCollectedAt`, `dataSources`, `generationMethod`, `warnings`, `completeness` 표시
- [ ] `completeness=PARTIAL`이면 `missingSignals`가 표시된다
- [ ] `changeHistoryLinks` 클릭 시 `/lineage/:entityType/:entityId`로 이동
- [ ] 새로고침/재조회 시 drawer는 기본 닫힘 상태 유지

**테스트:**

| 유형 | 케이스 | 예상 결과 |
|------|--------|----------|
| UI | PARTIAL completeness | missingSignals 목록 노출 |
| UI | FULL completeness | 경고 없음, 정상 표시 |
| UI | drawer 토글 | 열기/닫기 상태 전환 |
| 통합 | lineage 링크 클릭 | 해당 라우트로 이동 |

---

#### FE-302 — "액션 완료" 이벤트 훅 (대상 화면 저장 성공 시 Trace 업데이트)

| 항목 | 내용 |
|------|------|
| **Epic** | A3 |
| **설명** | 이슈/리스크/회의/재할당 등 대상 화면에서 "저장 성공" 시 trace에 completed 기록 |

**수용 기준 (AC):**

- [ ] AI에서 넘어온 요청 (`sourceInsight` 쿼리 파라미터 존재)인 경우에만 이벤트 발행
- [ ] 저장 성공 시 서버에 `ACTION_COMPLETED` trace 기록 호출
- [ ] 실패 시 `ACTION_FAILED`, 취소 시 `ACTION_CANCELLED` 기록
- [ ] `sourceInsight` 파라미터가 없으면 trace 이벤트 미발행 (기존 흐름 무영향)

**테스트:**

| 유형 | 케이스 | 예상 결과 |
|------|--------|----------|
| 통합 | AI 딥링크 → 저장 성공 | trace `ACTION_COMPLETED` + `action_completed_at` |
| 통합 | AI 딥링크 → 취소 | trace `ACTION_CANCELLED` |
| 통합 | 일반 접근 (sourceInsight 없음) → 저장 | trace 이벤트 미발행 |

---

### 17.4 백엔드 — Epic A1 (Rule-first MVP)

---

#### BE-201 — AI Briefing 조회 API (Rule-only, 캐시 포함)

| 항목 | 내용 |
|------|------|
| **Epic** | A1 |
| **Endpoint** | `GET /api/v2/projects/{projectId}/ai/briefing?role={role}&scope={scope}` |
| **설명** | Rule Engine 기반 브리핑 생성 + Redis 캐시. LLM 의존 없이 동작 |

**수용 기준 (AC):**

- [ ] 입력 파라미터 검증 (projectId/role/scope) 수행
- [ ] Redis 캐시 히트 시 200ms 내 응답 (목표)
- [ ] 캐시 미스 시 Rule Engine으로 브리핑 생성 후 응답
- [ ] 응답은 `AiBriefingResponse` 계약 (§4.1) 준수
- [ ] `asOf`는 서버에서 생성되고 모든 인사이트/evidence에 동일 적용 (B1 원칙)
- [ ] `completeness` 판정 포함 (B2 원칙)

**테스트:**

| 유형 | 케이스 | 예상 결과 |
|------|--------|----------|
| 통합 | 캐시 미스 | 생성 → 캐시 저장 → 응답 |
| 통합 | 캐시 히트 | 즉시 반환 (< 200ms) |
| 계약 | JSON schema | `AiBriefingResponse` 필드/타입 일치 |
| 단위 | asOf 일관성 | 모든 `evidence.asOf === context.asOf` |

---

#### BE-202 — Refresh API (캐시 무효화 + 즉시 재생성)

| 항목 | 내용 |
|------|------|
| **Epic** | A1 |
| **Endpoint** | `POST /api/v2/projects/{projectId}/ai/briefing/refresh` |
| **설명** | 캐시 무효화 + Rule 기반 즉시 재생성. LLM 보강은 백그라운드 (A4에서 추가) |

**수용 기준 (AC):**

- [ ] 호출 시 해당 cache key (`ai:briefing:{projectId}:{role}:{scope}`) 무효화
- [ ] Rule 기반 브리핑을 즉시 재생성하여 3초 내 반환
- [ ] 권한 체크 (최소 `view_ai_assistant`)
- [ ] Rate limit: 사용자당 30초 쿨다운 (남용 방지)

**테스트:**

| 유형 | 케이스 | 예상 결과 |
|------|--------|----------|
| 통합 | refresh 후 GET | 새 `asOf`가 이전과 다름 |
| 통합 | 30초 내 재호출 | 429 Too Many Requests |
| 단위 | 캐시 무효화 | Redis key 삭제 확인 |

---

#### BE-203 — Rule Engine v1 (지연/병목/품질/정책위반 최소셋)

| 항목 | 내용 |
|------|------|
| **Epic** | A1 |
| **설명** | 문서 §10.1 규칙 테이블 중 MVP 핵심만 구현 |

**MVP 규칙:**

| 규칙 ID | 유형 | 조건 | 심각도 |
|---------|------|------|--------|
| `R-DELAY-01` | DELAY | `due_date < NOW() AND status != 'DONE'` | 태스크 수 비례 MEDIUM~CRITICAL |
| `R-BOTTLE-01` | BOTTLENECK | `COUNT(active_tasks WHERE assignee=X) > 10` | MEDIUM |
| `R-QUALITY-01` | QUALITY | `test_pass_rate < 80%` (데이터 있으면) | HIGH |
| `R-POLICY-01` | POLICY_GAP | `governance.findings WHERE severity='HIGH'` (있으면) | HIGH |

**수용 기준 (AC):**

- [ ] 규칙은 deterministic (동일 데이터 → 동일 결과)
- [ ] severity 계산 로직이 문서 §10.1 기준을 따른다
- [ ] evidence (metrics/entities/dataSource)는 필수로 채운다
- [ ] 데이터 없는 규칙은 건너뛰고 `completeness=PARTIAL` + `missingSignals` 기록

**테스트:**

| 유형 | 케이스 | 예상 결과 |
|------|--------|----------|
| 단위 | R-DELAY-01 경계 | due_date = today → 미포함, due_date = yesterday → 포함 |
| 단위 | R-BOTTLE-01 경계 | active_tasks=10 → 미포함, 11 → 포함 |
| 단위 | 데이터 없음 | 해당 규칙 skip + PARTIAL warning |
| 단위 | 복합 | DELAY 3건 → severity=HIGH, 10건 → CRITICAL |

---

#### BE-204 — Explainability 메타 구성 (완결성/누락 신호)

| 항목 | 내용 |
|------|------|
| **Epic** | A1 |
| **설명** | `completeness` 산정 로직 + `missingSignals` + `warnings` 구성 |

**수용 기준 (AC):**

- [ ] completeness 산정: 모든 소스 정상=FULL, 일부 누락=PARTIAL, 판단 불가=UNKNOWN
- [ ] 누락 항목은 `missingSignals`에 기록 (예: `["commits_last_3d", "qa_test_runs"]`)
- [ ] `warnings`는 사용자 액션 가능한 문장 (예: "최근 7일 테스트 실행 데이터 없음")
- [ ] `dataSources[*].lastSyncAt` 포함 (데이터 신선도)

**테스트:**

| 유형 | 케이스 | 예상 결과 |
|------|--------|----------|
| 단위 | 모든 소스 정상 | `completeness=FULL`, missingSignals=[] |
| 단위 | Neo4j 12분 지연 | `completeness=PARTIAL`, warnings에 지연 메시지 |
| 단위 | 테스트 데이터 없음 | `missingSignals`에 "qa_test_runs" 포함 |

---

### 17.5 백엔드 — Epic A3 (Trace/감사 대응)

---

#### BE-301 — `ai.decision_trace_log` 스키마 적용 + 기록 포인트

| 항목 | 내용 |
|------|------|
| **Epic** | A3 |
| **설명** | §11.2 스키마를 DB migration으로 적용하고 기록 포인트 구현 |

**기록 포인트:**

| event_type | 트리거 | 기록 내용 |
|-----------|--------|---------|
| `BRIEFING_GENERATED` | GET /ai/briefing 응답 시 | briefing_id, role, asOf, generationMethod, completeness |
| `INSIGHT_VIEWED` | 프론트 카드 클릭 이벤트 | insightId, insightType, severity |
| `ACTION_CLICKED` | 프론트 액션 버튼 클릭 | actionId, action_clicked_at |
| `ACTION_COMPLETED` | 대상 화면 저장 성공 | action_completed_at |
| `ACTION_CANCELLED` | 대상 화면 취소 | action_result=CANCELLED |
| `CHAT_CONTEXT_INJECTED` | AskChatButton 클릭 | insightId 기반 |

**수용 기준 (AC):**

- [ ] DB migration 적용 (`ai` 스키마 + 테이블 + 인덱스)
- [ ] 브리핑 생성 시 trace 1건 자동 기록
- [ ] 프론트에서 POST `/ai/trace-log` 호출 시 이벤트 기록
- [ ] `action_result` 라이프사이클: CLICKED → COMPLETED / CANCELLED / FAILED

**테스트:**

| 유형 | 케이스 | 예상 결과 |
|------|--------|----------|
| 통합 | 브리핑 조회 | trace 1건 `BRIEFING_GENERATED` 기록 |
| 통합 | 액션 클릭 → 저장 | `ACTION_CLICKED` → `ACTION_COMPLETED` 2건 |
| 성능 | project_id + generated_at 인덱스 | 30일 조회 < 100ms |

---

### 17.6 LLM 서비스 — Epic A4 (Hybrid 고도화)

---

#### LLM-401 — `POST /api/ai/briefing/generate` (요약/문장화 전용)

| 항목 | 내용 |
|------|------|
| **Epic** | A4 |
| **설명** | Rule Findings + Raw Metrics 입력 → LLM이 headline/body 표현만 개선 |

**원칙:**

- LLM은 "추가 판단"을 만들지 않음 (초기)
- Rule 결과가 anchor — LLM은 표현/요약만 강화
- LLM 장애 시 Rule-only fallback 필수

**수용 기준 (AC):**

- [ ] LLM 장애 시에도 Rule-only 응답이 가능하다 (fallback)
- [ ] LLM 출력은 서버에서 스키마 검증 후 반영
- [ ] `generationMethod`는 `HYBRID`로 표시
- [ ] LLM 호출은 백그라운드로 실행, Rule-only 결과는 즉시 반환

**테스트:**

| 유형 | 케이스 | 예상 결과 |
|------|--------|----------|
| 통합 | LLM 정상 | headline/body가 자연어로 개선됨 |
| 통합 | LLM 장애 | Rule-only 응답 반환 (graceful degradation) |
| 계약 | 출력 스키마 | headline(string), body(string), generationMethod="HYBRID" |
| 성능 | LLM 응답 시간 | 백그라운드 < 8초, 프론트 체감 < 3초 (Rule-first) |

---

## 18. 파일/폴더 매핑 + 코드 스켈레톤

> 현재 레포 구조 기준으로 매핑. 경로는 프로젝트 루트(`pms-ic/`)로부터의 상대 경로.

### 18.1 프론트엔드 파일 구조

```
PMS_IC_FrontEnd_v1.2/src/
├── types/
│   └── aiBriefing.ts               ← [FE-102] 타입 정의 (신규)
├── hooks/
│   └── api/
│       └── useAiBriefing.ts         ← [FE-102] TanStack Query 훅 (신규)
├── stores/
│   └── aiChatBridgeStore.ts         ← [FE-107] 챗봇-콘솔 이벤트 버스 (신규)
├── app/
│   └── components/
│       ├── AIAssistant.tsx           ← [FE-107] 기존 파일 수정 (injectedContext 수신)
│       └── ai/                      ← AI 콘솔 전용 디렉토리 (신규)
│           ├── AiAssistantPage.tsx       ← [FE-101] 메인 페이지 레이아웃
│           ├── AiContextHeader.tsx       ← [FE-103] 맥락 헤더
│           ├── CompletenessIndicator.tsx ← [FE-103] FULL/PARTIAL/UNKNOWN 배지
│           ├── ScopeSelector.tsx         ← [FE-103] scope 변경 드롭다운
│           ├── AiBriefingPanel.tsx       ← [FE-104] 자동 요약 패널
│           ├── HealthStatusBadge.tsx     ← [FE-104] 건강도 배지
│           ├── SignalTagList.tsx         ← [FE-104] 감지 신호 태그 목록
│           ├── CompletenessWarning.tsx   ← [FE-104] PARTIAL 경고 배너
│           ├── InsightCardList.tsx       ← [FE-105] 인사이트 목록
│           ├── InsightCard.tsx           ← [FE-105] 개별 카드
│           ├── SeverityBadge.tsx         ← [FE-105] 심각도 배지
│           ├── ConfidenceIndicator.tsx   ← [FE-105] 신뢰도 표시
│           ├── EvidenceSummary.tsx       ← [FE-105] 근거 요약
│           ├── RecommendedActionPanel.tsx ← [FE-106] 추천 행동 허브
│           ├── ActionCard.tsx            ← [FE-106] 개별 액션 카드
│           ├── ActionButtonGroup.tsx     ← [FE-106] Capability 연동 버튼
│           ├── AskChatButton.tsx         ← [FE-107] 챗봇 컨텍스트 주입 버튼
│           ├── ExplainabilityDrawer.tsx  ← [FE-108] 설명 책임 패널
│           ├── DataSourceList.tsx        ← [FE-108] 데이터 소스 목록
│           ├── WarningList.tsx           ← [FE-108] 경고 목록
│           └── ChangeHistoryLinks.tsx    ← [FE-108] Lineage 딥링크
├── router/
│   └── index.tsx                    ← [FE-101] 라우트 등록 수정
└── services/
    └── api.ts                       ← [FE-102] API 엔드포인트 추가
```

### 18.2 백엔드 파일 구조

```
PMS_IC_BackEnd_v1.2/src/main/
├── java/com/insuretech/pms/
│   └── ai/                          ← AI 브리핑 전용 패키지 (신규)
│       ├── controller/
│       │   └── ReactiveAiBriefingController.java  ← [BE-201, BE-202]
│       ├── service/
│       │   ├── AiBriefingService.java             ← [BE-201] 브리핑 조립
│       │   ├── RuleEngineService.java             ← [BE-203] 규칙 엔진
│       │   ├── CompletenessService.java           ← [BE-204] 완결성 판정
│       │   └── AiDecisionTraceService.java        ← [BE-301] Trace 기록
│       ├── rule/
│       │   ├── DelayRule.java                     ← [BE-203] R-DELAY-01/02
│       │   ├── BottleneckRule.java                ← [BE-203] R-BOTTLE-01/02
│       │   ├── QualityRule.java                   ← [BE-203] R-QUALITY-01/02
│       │   └── PolicyGapRule.java                 ← [BE-203] R-POLICY-01
│       ├── cache/
│       │   └── AiBriefingCacheService.java        ← [BE-201] Redis 캐시
│       ├── dto/
│       │   ├── AiBriefingResponse.java            ← [BE-201] 응답 DTO
│       │   ├── AiInsightDto.java                  ← [BE-201] 인사이트 DTO
│       │   ├── AiRecommendedActionDto.java        ← [BE-201] 추천 행동 DTO
│       │   └── AiExplainabilityDto.java           ← [BE-204] 설명 책임 DTO
│       └── entity/
│           └── R2dbcDecisionTraceLog.java         ← [BE-301] R2DBC 엔티티
└── resources/
    └── db/migration/
        └── V20260210__ai_decision_trace_log.sql   ← [BE-301] DDL
```

### 18.3 LLM 서비스 파일 구조

```
llm-service/
├── routes/
│   └── ai_briefing_routes.py        ← [LLM-401] Flask 엔드포인트 (신규)
├── services/
│   └── briefing_summarizer.py       ← [LLM-401] LLM 요약 서비스 (신규)
└── tests/
    └── test_ai_briefing.py          ← [LLM-401] 테스트 (신규)
```

### 18.4 코드 스켈레톤 — 프론트엔드 타입 (`aiBriefing.ts`)

```typescript
// src/types/aiBriefing.ts
// [FE-102] AiBriefingResponse 단일 소스 타입 정의
// 문서 §4.1~4.4의 스키마를 1:1 대응

export type BriefingScope = 'current_sprint' | 'last_7_days' | 'last_14_days' | 'current_phase';
export type Completeness = 'FULL' | 'PARTIAL' | 'UNKNOWN';
export type HealthStatus = 'GREEN' | 'YELLOW' | 'RED';
export type InsightType = 'DELAY' | 'RISK' | 'BOTTLENECK' | 'POLICY_GAP' | 'QUALITY' | 'PROGRESS' | 'RESOURCE' | 'POSITIVE';
export type Severity = 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW' | 'INFO';
export type GenerationMethod = 'RULE_BASED' | 'MODEL_BASED' | 'HYBRID';

export interface AiBriefingResponse {
  context: {
    projectId: string;
    role: string;
    asOf: string;                    // ISO 8601
    scope: BriefingScope;
    completeness: Completeness;
    missingSignals?: string[];
  };
  summary: {
    headline: string;
    signals: string[];
    healthStatus: HealthStatus;
    confidence: number;              // 0.0 ~ 1.0
    body: string;
  };
  insights: AiInsight[];
  recommendedActions: AiRecommendedAction[];
  explainability: AiExplainability;
}

export interface AiInsight {
  id: string;
  type: InsightType;
  severity: Severity;
  title: string;
  description: string;
  confidence: number;
  evidence: {
    asOf: string;                    // === context.asOf (B1 원칙)
    metrics: string[];
    entities: string[];
    dataSource: string;
    query?: string;
  };
  actionRefs: string[];
}

export interface AiRecommendedAction {
  actionId: string;
  label: string;
  description: string;
  requiredCapability: string;
  targetRoute: string;
  priority: number;
  sourceInsightIds: string[];
}

export interface AiExplainability {
  dataCollectedAt: string;
  completeness: Completeness;
  missingSignals: string[];
  dataSources: {
    source: string;
    tables?: string[];
    recordCount?: number;
    lastSyncAt?: string;
  }[];
  generationMethod: GenerationMethod;
  warnings: string[];
  changeHistoryLinks: {
    label: string;
    route: string;
  }[];
}
```

### 18.5 코드 스켈레톤 — API 훅 (`useAiBriefing.ts`)

```typescript
// src/hooks/api/useAiBriefing.ts
// [FE-102] TanStack Query 훅
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import type { AiBriefingResponse, BriefingScope } from '@/types/aiBriefing';
import { apiService } from '@/services/api';

export const aiBriefingKeys = {
  all: ['ai-briefing'] as const,
  briefing: (projectId: string, role: string, scope?: string) =>
    [...aiBriefingKeys.all, projectId, role, scope ?? 'default'] as const,
};

export function useAiBriefing(
  projectId: string | undefined,
  role: string,
  scope?: BriefingScope,
) {
  return useQuery<AiBriefingResponse>({
    queryKey: aiBriefingKeys.briefing(projectId ?? '', role, scope),
    queryFn: () => apiService.getAiBriefing(projectId!, role, scope),
    enabled: !!projectId,
    staleTime: 5 * 60 * 1000,       // 5min
    refetchOnWindowFocus: false,
  });
}

export function useRefreshBriefing() {
  const qc = useQueryClient();
  return useMutation({
    mutationFn: ({ projectId, role, scope }: {
      projectId: string; role: string; scope?: BriefingScope;
    }) => apiService.refreshAiBriefing(projectId, role, scope),
    onSuccess: (_, { projectId, role, scope }) => {
      qc.invalidateQueries({
        queryKey: aiBriefingKeys.briefing(projectId, role, scope),
      });
    },
  });
}
```

### 18.6 코드 스켈레톤 — 챗봇-콘솔 이벤트 브릿지 (`aiChatBridgeStore.ts`)

```typescript
// src/stores/aiChatBridgeStore.ts
// [FE-107] Zustand store — AI 콘솔 → 오른쪽 챗봇 컨텍스트 전달
import { create } from 'zustand';

export interface AiChatContextInjection {
  mode: 'CONTEXTUAL';
  injectedContext: {
    insightId: string;
    insightType: string;
    insightTitle: string;
    projectId: string;
    asOf: string;
    evidenceRef: string[];
    summary: string;
  };
}

interface AiChatBridgeState {
  pending: AiChatContextInjection | null;
  inject: (ctx: AiChatContextInjection) => void;
  consume: () => AiChatContextInjection | null;
}

export const useAiChatBridgeStore = create<AiChatBridgeState>((set, get) => ({
  pending: null,
  inject: (ctx) => set({ pending: ctx }),
  consume: () => {
    const ctx = get().pending;
    set({ pending: null });
    return ctx;
  },
}));
```

### 18.7 코드 스켈레톤 — 페이지 레이아웃 (`AiAssistantPage.tsx`)

```typescript
// src/app/components/ai/AiAssistantPage.tsx
// [FE-101] 메인 페이지 — 5개 영역(A~E) 레이아웃 쉘
import React, { Suspense } from 'react';
import { useProject } from '@/contexts/ProjectContext';
import { useAiBriefing } from '@/hooks/api/useAiBriefing';
import { useCapabilities } from '@/hooks/useCapabilities';

// Lazy-loaded sections
const AiContextHeader = React.lazy(() => import('./AiContextHeader'));
const AiBriefingPanel = React.lazy(() => import('./AiBriefingPanel'));
const InsightCardList = React.lazy(() => import('./InsightCardList'));
const RecommendedActionPanel = React.lazy(() => import('./RecommendedActionPanel'));
const ExplainabilityDrawer = React.lazy(() => import('./ExplainabilityDrawer'));

interface Props {
  userRole?: string;
}

export default function AiAssistantPage({ userRole }: Props) {
  const { currentProject } = useProject();
  const role = userRole ?? 'pm';
  const [scope, setScope] = React.useState<string | undefined>();

  const {
    data: briefing,
    isLoading,
    isError,
    refetch,
  } = useAiBriefing(currentProject?.id, role, scope as any);

  if (isLoading) return <BriefingSkeleton />;
  if (isError) return <ErrorState onRetry={refetch} />;
  if (!briefing) return <EmptyState message="브리핑 데이터가 없습니다" />;

  return (
    <div className="flex flex-col gap-6 p-6">
      {/* [A] Context Header */}
      <Suspense fallback={<div className="h-16 animate-pulse bg-gray-100 rounded" />}>
        <AiContextHeader
          briefing={briefing}
          scope={scope}
          onScopeChange={setScope}
          onRefresh={() => refetch()}
        />
      </Suspense>

      {/* [B] Briefing Panel */}
      <Suspense fallback={<div className="h-40 animate-pulse bg-gray-100 rounded" />}>
        <AiBriefingPanel summary={briefing.summary} context={briefing.context} />
      </Suspense>

      {/* [C] Insight Cards */}
      <Suspense fallback={<div className="h-60 animate-pulse bg-gray-100 rounded" />}>
        <InsightCardList
          insights={briefing.insights}
          actions={briefing.recommendedActions}
        />
      </Suspense>

      {/* [D] Recommended Actions */}
      <Suspense fallback={<div className="h-32 animate-pulse bg-gray-100 rounded" />}>
        <RecommendedActionPanel
          actions={briefing.recommendedActions}
          context={briefing.context}
        />
      </Suspense>

      {/* [E] Explainability Drawer */}
      <Suspense fallback={null}>
        <ExplainabilityDrawer explainability={briefing.explainability} />
      </Suspense>
    </div>
  );
}

function BriefingSkeleton() {
  return (
    <div className="flex flex-col gap-6 p-6">
      <div className="h-16 animate-pulse bg-gray-100 rounded" />
      <div className="h-40 animate-pulse bg-gray-100 rounded" />
      <div className="h-60 animate-pulse bg-gray-100 rounded" />
      <div className="h-32 animate-pulse bg-gray-100 rounded" />
    </div>
  );
}

function ErrorState({ onRetry }: { onRetry: () => void }) {
  return (
    <div className="flex flex-col items-center justify-center gap-4 p-12 text-center">
      <p className="text-gray-600">브리핑을 불러오는 중 오류가 발생했습니다.</p>
      <button
        onClick={onRetry}
        className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
      >
        다시 시도
      </button>
    </div>
  );
}

function EmptyState({ message }: { message: string }) {
  return (
    <div className="flex items-center justify-center p-12 text-gray-500">
      {message}
    </div>
  );
}
```

### 18.8 코드 스켈레톤 — 백엔드 컨트롤러

```java
// PMS_IC_BackEnd_v1.2/src/main/java/com/insuretech/pms/ai/controller/
// ReactiveAiBriefingController.java
// [BE-201, BE-202]

@RestController
@RequestMapping("/api/v2/projects/{projectId}/ai")
@RequiredArgsConstructor
public class ReactiveAiBriefingController {

    private final AiBriefingService briefingService;
    private final AiDecisionTraceService traceService;

    @GetMapping("/briefing")
    public Mono<ApiResponse<AiBriefingResponse>> getBriefing(
            @PathVariable String projectId,
            @RequestParam String role,
            @RequestParam(required = false) String scope,
            @AuthenticationPrincipal UserPrincipal user) {
        return briefingService
            .getBriefing(projectId, role, scope)
            .doOnSuccess(b -> traceService.recordBriefingGenerated(b, user))
            .map(ApiResponse::success);
    }

    @PostMapping("/briefing/refresh")
    public Mono<ApiResponse<AiBriefingResponse>> refreshBriefing(
            @PathVariable String projectId,
            @RequestParam String role,
            @RequestParam(required = false) String scope,
            @AuthenticationPrincipal UserPrincipal user) {
        return briefingService
            .refreshBriefing(projectId, role, scope)
            .map(ApiResponse::success);
    }

    @PostMapping("/trace-log")
    public Mono<ApiResponse<Void>> recordTraceEvent(
            @PathVariable String projectId,
            @RequestBody TraceEventRequest request,
            @AuthenticationPrincipal UserPrincipal user) {
        return traceService
            .recordEvent(projectId, request, user)
            .then(Mono.just(ApiResponse.success(null)));
    }

    @GetMapping("/trace-log")
    public Flux<DecisionTraceLogDto> getTraceLog(
            @PathVariable String projectId,
            @RequestParam(required = false) String from,
            @RequestParam(required = false) String to,
            @RequestParam(required = false) String eventType) {
        return traceService.queryLogs(projectId, from, to, eventType);
    }
}
```

### 18.9 코드 스켈레톤 — LLM 서비스 엔드포인트

```python
# llm-service/routes/ai_briefing_routes.py
# [LLM-401] Flask blueprint — Rule 결과를 LLM으로 요약/문장화

from flask import Blueprint, request, jsonify
import logging

ai_briefing_bp = Blueprint("ai_briefing", __name__)
logger = logging.getLogger(__name__)

@ai_briefing_bp.route("/api/ai/briefing/generate", methods=["POST"])
def generate_briefing_summary():
    """
    Rule Findings + Raw Metrics -> LLM headline/body generation.
    LLM is SUMMARIZER only (no new judgments in v1).
    """
    data = request.get_json()
    project_id = data.get("projectId")
    role = data.get("role", "PM")
    as_of = data.get("asOf")
    raw_metrics = data.get("rawMetrics", {})
    rule_findings = data.get("ruleFindings", [])
    completeness = data.get("completeness", "UNKNOWN")
    missing_signals = data.get("missingSignals", [])

    try:
        from services.briefing_summarizer import BriefingSummarizer
        summarizer = BriefingSummarizer()
        result = summarizer.summarize(
            role=role,
            metrics=raw_metrics,
            findings=rule_findings,
            completeness=completeness,
            missing_signals=missing_signals,
        )
        return jsonify({
            "headline": result["headline"],
            "body": result["body"],
            "insights": result.get("insights", []),
            "generationMethod": "HYBRID",
        })
    except Exception as e:
        logger.error(f"LLM briefing generation failed: {e}")
        # Fallback: return empty so caller uses Rule-only
        return jsonify({
            "headline": "",
            "body": "",
            "insights": [],
            "generationMethod": "RULE_BASED",
            "error": str(e),
        }), 200  # 200 with empty — caller decides fallback
```

### 18.10 코드 스켈레톤 — DB Migration

```sql
-- PMS_IC_BackEnd_v1.2/src/main/resources/db/migration/
-- V20260210__ai_decision_trace_log.sql
-- [BE-301] AI Decision Trace Log

CREATE SCHEMA IF NOT EXISTS ai;

CREATE TABLE IF NOT EXISTS ai.decision_trace_log (
  id                VARCHAR(36) PRIMARY KEY,
  project_id        VARCHAR(36) NOT NULL,
  user_id           VARCHAR(36) NOT NULL,
  user_role         VARCHAR(50) NOT NULL,

  event_type        VARCHAR(30) NOT NULL,

  briefing_id       VARCHAR(36) NOT NULL,
  insight_id        VARCHAR(36),
  insight_type      VARCHAR(50),
  severity          VARCHAR(20),
  confidence        DECIMAL(3,2),

  action_id         VARCHAR(50),
  action_result     VARCHAR(20),

  generation_method VARCHAR(20),
  completeness      VARCHAR(10),
  data_sources      JSONB,
  evidence_json     JSONB,
  as_of             TIMESTAMPTZ,

  generated_at      TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  action_clicked_at   TIMESTAMPTZ,
  action_completed_at TIMESTAMPTZ,

  CONSTRAINT fk_trace_project
    FOREIGN KEY (project_id) REFERENCES project.projects(id)
);

CREATE INDEX idx_trace_project   ON ai.decision_trace_log(project_id, generated_at);
CREATE INDEX idx_trace_user      ON ai.decision_trace_log(user_id, generated_at);
CREATE INDEX idx_trace_event     ON ai.decision_trace_log(event_type, generated_at);
CREATE INDEX idx_trace_action    ON ai.decision_trace_log(action_id, action_result)
  WHERE action_id IS NOT NULL;
```

### 18.11 라우터 등록 변경 (`router/index.tsx`)

```typescript
// src/router/index.tsx — [FE-101] 기존 PlaceholderPage → AiAssistantPage 교체

// Before:
// const AiAssistantPage = React.lazy(() => import('../app/components/PlaceholderPage'));

// After:
const AiAssistantPage = React.lazy(
  () => import('../app/components/ai/AiAssistantPage')
);

// Route 등록 (기존 위치 유지):
// <Route path="/ai-assistant" element={
//   <ProtectedRoute requiredCaps={['view_ai_assistant']}>
//     <AiAssistantPage />
//   </ProtectedRoute>
// } />
```

### 18.12 API 서비스 확장 (`services/api.ts`)

```typescript
// src/services/api.ts — [FE-102] AI Briefing API 추가

// 기존 apiService 객체에 추가:
async getAiBriefing(
  projectId: string,
  role: string,
  scope?: string,
): Promise<AiBriefingResponse> {
  const params = new URLSearchParams({ role });
  if (scope) params.set('scope', scope);
  return this.get(`/v2/projects/${projectId}/ai/briefing?${params}`);
},

async refreshAiBriefing(
  projectId: string,
  role: string,
  scope?: string,
): Promise<AiBriefingResponse> {
  const params = new URLSearchParams({ role });
  if (scope) params.set('scope', scope);
  return this.post(`/v2/projects/${projectId}/ai/briefing/refresh?${params}`);
},

async recordAiTraceEvent(
  projectId: string,
  event: TraceEventRequest,
): Promise<void> {
  return this.post(`/v2/projects/${projectId}/ai/trace-log`, event);
},
```

---

## 19. 운영 수용 테스트 시나리오 (MVP)

> 아래 6개만 통과하면 MVP는 **"진짜 쓸 수 있는 콘솔"**이 된다.

### 시나리오 1: PM 전체 흐름 (Happy Path)

```
PM이 /ai-assistant 진입
  → 지연 인사이트 1개 노출
  → "이슈로 등록" 버튼 클릭
  → /issues?action=new&sourceInsight=insight-delay-01 이동
  → 이슈 등록 폼에 제목/설명 프리필 확인
  → 저장 성공
  → ai.decision_trace_log에 ACTION_COMPLETED 기록 확인
```

**검증 포인트:**
- [ ] 인사이트 카드에 DELAY 유형 표시
- [ ] 버튼에 `manage_issues` Capability 검증
- [ ] 이슈 폼에 "[AI 감지]" 접두사 프리필
- [ ] Change History에 `source: 'AI_INSIGHT'` 기록

### 시나리오 2: DEV 역할 필터링

```
Developer 계정으로 /ai-assistant 진입
  → 내 담당 작업 중심 인사이트만 필터
  → "내 작업으로 이동" 액션 정상 동작
  → PMO 에스컬레이션 버튼 미노출 (manage_pmo 없음)
```

**검증 포인트:**
- [ ] Preset: `DEV_EXECUTION` 자동 적용
- [ ] 인사이트가 내 담당 작업 위주로 필터
- [ ] `manage_pmo` 버튼 렌더링 안 됨

### 시나리오 3: PMO 정책 위반 감지

```
PMO 계정으로 /ai-assistant 진입
  → POLICY_GAP 인사이트 노출
  → "거버넌스 점검" 딥링크 클릭
  → /role-permission?tab=governance 정상 이동
```

**검증 포인트:**
- [ ] Preset: `PMO_CONTROL` 자동 적용
- [ ] POLICY_GAP 카드에 severity=HIGH
- [ ] 딥링크 대상 Route Guard 통과

### 시나리오 4: 데이터 누락 상태 (PARTIAL)

```
테스트 데이터 없는 프로젝트에서 /ai-assistant 진입
  → AiContextHeader에 PARTIAL 배지 표시
  → AiBriefingPanel에 경고 배너 표시
  → ExplainabilityDrawer 열기 → missingSignals/warnings 확인
```

**검증 포인트:**
- [ ] `completeness=PARTIAL` 표시
- [ ] missingSignals 구체적 항목 나열
- [ ] warnings에 사용자 액션 가능한 문장

### 시나리오 5: 챗봇 컨텍스트 주입

```
인사이트 카드에서 "이 내용에 대해 질문하기" 클릭
  → 오른쪽 챗봇 패널 열림
  → 챗봇에 insight context 주입 확인
  → ai.decision_trace_log에 CHAT_CONTEXT_INJECTED 기록
```

**검증 포인트:**
- [ ] 챗봇 패널 자동 오픈
- [ ] 시스템 메시지에 insightId/asOf/evidenceRef 포함
- [ ] 챗봇이 해당 인사이트 범위 내에서 응답

### 시나리오 6: 이중 보호 (권한 없는 유저)

```
view_ai_assistant는 있지만 manage_risks 없는 유저
  → /ai-assistant 진입 성공
  → 인사이트 카드 표시됨
  → "리스크 등록" 버튼 disabled + 툴팁 "권한이 필요합니다"
  → URL 직접 입력으로 /decision-risk?action=new 시도
  → 대상 화면 Route Guard에서 403
```

**검증 포인트:**
- [ ] 콘솔 진입: OK
- [ ] 버튼 렌더: disabled + 툴팁
- [ ] 직접 URL 접근: 403 (이중 보호)
